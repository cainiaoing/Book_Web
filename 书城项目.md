## 1、第一阶段：表单验证

```markdown
这是针对注册界面的。
验证用户名：必须由字母，数字下划线组成，并且长度为 5 到 12 位

验证密码：必须由字母，数字下划线组成，并且长度为 5 到 12 位

验证确认密码：和密码相同

邮箱验证：xxxxx@xxx.com

验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成。
```

```markdown
再IDEA里面建立一个Static Web -> book_static
把书城的静态资源拷贝到book_static工程下
	index是首页，
	pages是各种页面
		cart购物车
		managger是后台
		order是订单
		user是用户
	static是一些静态资源，img啦，css啦
第一步：再regist.html里面引入jquery；
	把jquery-1.7.2.js引进static里面，目录是script
	
```

对regist.html操作

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>尚硅谷会员注册页面</title>
	<link type="text/css" rel="stylesheet" href="../../static/css/style.css" >
	<script type="text/javascript" src="../../static/script/jquery-1.7.2.js"></script>
	<script type="text/javascript">
		// 页面加载完成之后
		$(function () {
			// 给注册绑定单击事件
			$("#sub_btn").click(function () {
				// 验证用户名：必须由字母，数字下划线组成，并且长度为5到12位
				//1 获取用户名输入框里的内容
				var usernameText = $("#username").val();
				//2 创建正则表达式对象
				var usernamePatt = /^\w{5,12}$/;
				//3 使用test方法验证
				if (!usernamePatt.test(usernameText)) {
					//4 提示用户结果
					$("span.errorMsg").text("用户名不合法！");

					return false;//阻止默认的输入完用户名后，发生跳转
				}

				// 验证密码：必须由字母，数字下划线组成，并且长度为5到12位
				//1 获取用户名输入框里的内容
				var passwordText = $("#password").val();
				//2 创建正则表达式对象
				var passwordPatt = /^\w{5,12}$/;
				//3 使用test方法验证
				if (!passwordPatt.test(passwordText)) {
					//4 提示用户结果
					$("span.errorMsg").text("密码不合法！");

					return false;
				}

				// 验证确认密码：和密码相同
				//1 获取确认密码内容
				var repwdText = $("#repwd").val();
				//2 和密码相比较
				if (repwdText != passwordText) {
					//3 提示用户
					$("span.errorMsg").text("确认密码和密码不一致！");

					return false;
				}

				// 邮箱验证：xxxxx@xxx.com
				//1 获取邮箱里的内容
				var emailText = $("#email").val();
				//2 创建正则表达式对象
				var emailPatt = /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/;
				//3 使用test方法验证是否合法
				if (!emailPatt.test(emailText)) {
					//4 提示用户
					$("span.errorMsg").text("邮箱格式不合法！");

					return false;
				}

				// 验证码：现在只需要验证用户已输入。因为还没讲到服务器。验证码生成。
				var codeText = $("#code").val();

				//去掉验证码前后空格
				// alert("去空格前：["+codeText+"]")
				codeText = $.trim(codeText);
				// alert("去空格后：["+codeText+"]")

				if (codeText == null || codeText == "") {
					//4 提示用户
					$("span.errorMsg").text("验证码不能为空！");

					return false;
				}

				// 去掉错误信息，这个是避免服务器访问慢，发生此界面还出现提示用户的信息，用此语句，就避免了，注册成功了，还有错误提示信息
				$("span.errorMsg").text("");

			});

		});

	</script>
	<style type="text/css">
		.login_form{
			height:420px;
			margin-top: 25px;
		}

	</style>
</head>
<body>
	<div id="login_header">
		<img class="logo_img" alt="" src="../../static/img/logo.gif" >
	</div>

	<div class="login_banner">

		<div id="l_content">
			<span class="login_word">欢迎注册</span>
		</div>

		<div id="content">
			<div class="login_form">
				<div class="login_box">
					<div class="tit">
						<h1>注册尚硅谷会员</h1>
						<span class="errorMsg"></span>
					</div>
					<div class="form">
						<form action="http://localhost:8080">
							<label>用户名称：</label>
							<input class="itxt" type="text" placeholder="请输入用户名"
								   autocomplete="off" tabindex="1" name="username" id="username" />
							<br />
							<br />
							<label>用户密码：</label>
							<input class="itxt" type="password" placeholder="请输入密码"
								   autocomplete="off" tabindex="1" name="password" id="password" />
							<br />
							<br />
							<label>确认密码：</label>
							<input class="itxt" type="password" placeholder="确认密码"
								   autocomplete="off" tabindex="1" name="repwd" id="repwd" />
							<br />
							<br />
							<label>电子邮件：</label>
							<input class="itxt" type="text" placeholder="请输入邮箱地址"
								   autocomplete="off" tabindex="1" name="email" id="email" />
							<br />
							<br />
							<label>验证码：</label>
							<input class="itxt" type="text" style="width: 150px;" id="code"/>
							<img alt="" src="../../static/img/code.bmp" style="float: right; margin-right: 40px">
							<br />
							<br />
							<input type="submit" value="注册" id="sub_btn" />
						</form>
					</div>

				</div>
			</div>
		</div>
	</div>
	<div id="bottom">
				<span>
					尚硅谷书城.Copyright &copy;2015
				</span>
	</div>
</body>
</html>
```

## 2、用户登陆和注册

```markdown
# 主要功能
	注册界面：
		通过在表单中输入数据，并把数据交给服务器，让服务器验证后去提交到数据库，
	登陆界面：
		通过在表单中输入数据，并把数据在数据库中去验证，验证成功就跳转到下一个界面，验证不成功，就提示用户报错信息去继续登陆。
```

### 1、javaEE的三层架构

![image-20211028222057378](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211028222057378.png)

> 分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级

这是环境的搭建

```markdown
web 层		   com.atguigu.web/servlet/controller
service 层	   com.atguigu.service			 	     Service 接口包
			   com.atguigu.service.impl 		     Service 接口实现类
dao 持久层 	  com.atguigu.dao 					   Dao 接口包
			   com.atguigu.dao.impl 			    Dao 接口实现类
实体 bean 对象   com.atguigu.pojo/entity/domain/bean   JavaBean 类
测试包 		 com.atguigu.test/junit
工具类 		 com.atguigu.utils
```

![image-20211101203544779](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211101203544779.png)

### 2、线创建书城所需要的数据库和表

```mysql
DROP DATABASE IF EXISTS book;
CREATE DATABASE book;
USE book;
CREATE TABLE t_user(
    `id` INT PRIMARY KEY AUTO_INCREMENT,-- 这是自增，所以下面的values不写
    `username` VARCHAR(20) NOT NULL UNIQUE,
    `password` VARCHAR(32) NOT NULL,
    `email` VARCHAR(200)
);
INSERT INTO t_user(`username`,`password`,`email`) VALUES('admin','admin','admin@atguigu.com');
SELECT * FROM t_user;
```

### 3、编写数据库表对应的JavaBean对象

JavaBean的概念

```markdown
	Java语言欠缺属性、事件、多重继承功能。
	所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。
	Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。
	遵守上述约定的类可以用于若干工具或库。
```

JavaBean的编写（对应数据库的）

```java
package com.atguigu.pojo;//pojo这个类就是写类的

public class User {
    private Integer id;
    private String username;
    private String password;
    private String email;
    //快捷键alt+insert生成get和set方法

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
    //相同的方式生成toString

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
    //相同的方式编写有参类和无参类
    public User(Integer id, String username, String password, String email) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
    }

    public User() {
    }
}

```

> 在编写dao持久层之前需要编写工具类，这个工具类主要用来跟数据库联通

### 4、编写工具类JdbcUtils

#### 1、导入需要的jar包（数据库和连接池需要）

druid-1.1.9.jar

mysql-connector-java-5.1.7-bin.jar

以下是测试需要导入到包

hamcrest-core-1.3.jar

junit-4.12.jar

#### 2、在src源码目录下编写jdbc.properties数据配置文件

```properties
username=root
password=kdh77585219513
url=jdbc:mysql://localhost:3306/book
driverClassName=com.mysql.jdbc.Driver
# 初始化的数量
initialSize=5 
# 最大连接数
maxActive=10

# 但是我个人的mysql版本是8.0.13所以有变动
# mysql-connector-java-8.0.13.jar 和drudi-1.0.9.jar
username=root
password=kdh77585219513
url=jdbc:mysql://localhost:3306/book?serverTimezone=UTC&useSSL=true
driverClassName=com.mysql.cj.jdbc.Driver
# 初始化的数量
initialSize=5
# 最大连接数
maxActive=10

# 以下是自己添加的部分
filters=stat
maxWait=60000
timeBetweenEvictionRunsMillis=60000
minEvictableIdleTimeMillis=300000
validationQuery=SELECT 1
testWhileIdle=true
testOnBorrow=false
testOnReturn=false
poolPreparedStatements=false
maxPoolPreparedStatementPerConnectionSize=200

```

#### 3、编写JdbcUtils工具类

```java
package com.atguigu.utils;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidDataSourceFactory;

import java.io.InputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;

public class JdbcUtils {

    private static DruidDataSource dataSource;

    static {
        try {
            Properties properties = new Properties();
            // 读取 jdbc.properties属性配置文件
            InputStream inputStream = JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
            // 从流中加载数据
            properties.load(inputStream);
            // 创建 数据库连接 池
            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * 获取数据库连接池中的连接
     * @return 如果返回null,说明获取连接失败<br/>有值就是获取连接成功
     */
    public static Connection getConnection(){

        Connection conn = null;

        try {
            conn = dataSource.getConnection();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return conn;
    }

    /**
     * 关闭连接，放回数据库连接池
     * @param conn
     */
    public static void close(Connection conn){
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}

```

#### 4、JdbcUtils测试

```java
package com.atguigu.test;

import com.atguigu.utils.JdbcUtils;
import org.junit.Test;

import java.sql.Connection;

public class JdbcUtilsTest {

    @Test//这个是导入测试类的架包的，从而完成测试数据库的连接
    public void testJdbcUtils(){
        for (int i = 0; i < 100; i++){
            Connection connection = JdbcUtils.getConnection();
            System.out.println(connection);
            JdbcUtils.close(connection);//这个一定要断开连接，因为在配置文件设置的最大资源数是10个，断开之后才能一直不断地连接
        }
    }

}

```

### 5、编写BaseDao

#### 1、导入 DBUtils 的 的 jar 包 包
commons-dbutils-1.3.jar

#### 2、编写BaseDao

```java
package com.atguigu.dao.impl;

import com.atguigu.utils.JdbcUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

public abstract class BaseDao {//abstract是为了提高代码复用

    //使用DbUtils操作数据库
    private QueryRunner queryRunner = new QueryRunner();

    /**
     * update() 方法用来执行：Insert\Update\Delete语句
     *
     * @return 如果返回-1,说明执行失败<br/>返回其他表示影响的行数
     */
    public int update(String sql, Object... args) { //...args表示可变长参数，用来接受特殊的sql语句的特殊占位符
        Connection connection = JdbcUtils.getConnection();
        try {
            return queryRunner.update(connection, sql, args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(connection);
        }
        return -1;
    }

    /**
     * 查询返回一个javaBean的sql语句
     *
     * @param type 返回的对象类型
     * @param sql  执行的sql语句
     * @param args sql对应的参数值
     * @param <T>  返回的类型的泛型
     * @return
     */
    public <T> T queryForOne(Class<T> type, String sql, Object... args) { //查询返回一个javaBean的sql语句
        Connection con = JdbcUtils.getConnection();
        try {
            return queryRunner.query(con, sql, new BeanHandler<T>(type), args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(con);
        }
        return null;
    }

    /**
     * 查询返回多个javaBean的sql语句
     *
     * @param type 返回的对象类型
     * @param sql  执行的sql语句
     * @param args sql对应的参数值
     * @param <T>  返回的类型的泛型
     * @return
     */
    public <T> List<T> queryForList(Class<T> type, String sql, Object... args) {
        Connection con = JdbcUtils.getConnection();
        try {
            return queryRunner.query(con, sql, new BeanListHandler<T>(type), args);
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(con);
        }
        return null;
    }

    /**
     * 执行返回一行一列的sql语句
     * @param sql   执行的sql语句
     * @param args  sql对应的参数值
     * @return
     */
    public Object queryForSingleValue(String sql, Object... args){

        Connection conn = JdbcUtils.getConnection();

        try {
            return queryRunner.query(conn, sql, new ScalarHandler(), args);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            JdbcUtils.close(conn);
        }
        return null;

    }

}

```

#### 3、编写UserDao接口

```java
package com.atguigu.dao;

import com.atguigu.pojo.User;

public interface UserDao {
    /**
     * 根据用户名查询用户信息  从界面中的信息放到这里，然后在交给数据库去查询
     * @param username 用户名
     * @return 如果返回null,说明没有这个用户。反之亦然
     */
    public User queryUserByUsername(String username);

    /**
     * 根据 用户名和密码查询用户信息
     * @param username
     * @param password
     * @return 如果返回null,说明用户名或密码错误,反之亦然
     */
    public User queryUserByUsernameAndPassword(String username,String password);

    /**
     * 保存用户信息
     * @param user
     * @return 返回-1表示操作失败，其他是sql语句影响的行数
     */
    public int saveUser(User user);

}
```

#### 4、UserDaoImpl实现类

```java
package com.atguigu.dao.impl;

import com.atguigu.dao.UserDao;
import com.atguigu.pojo.User;

//UserDao的测试类

public class UserDaoImpl extends BaseDao implements UserDao {
    @Override
    public User queryUserByUsername(String username) {
        String sql = "select `id`,`username`,`password`,`email` from t_user where username = ?";
        return queryForOne(User.class, sql, username);
    }

    @Override
    public User queryUserByUsernameAndPassword(String username, String password) {
        String sql = "select `id`,`username`,`password`,`email` from t_user where username = ? and password = ?";
        return queryForOne(User.class, sql, username,password);
    }

    @Override
    public int saveUser(User user) {
        String sql = "insert into t_user(`username`,`password`,`email`) values(?,?,?)";
        return update(sql, user.getUsername(),user.getPassword(),user.getEmail());
    }
}

```

#### 5、UserDaoTest测试类

```java
package com.atguigu.test;

import com.atguigu.dao.UserDao;
import com.atguigu.dao.impl.UserDaoImpl;
import com.atguigu.pojo.User;
import org.junit.Test;

import static org.junit.Assert.*;

public class UserDaoTest {

    UserDao userDao = new UserDaoImpl();

    @Test
    public void queryUserByUsername() {

        if (userDao.queryUserByUsername("admin1234") == null ){
            System.out.println("用户名可用！");
        } else {
            System.out.println("用户名已存在！");
        }
    }

    @Test
    public void queryUserByUsernameAndPassword() {
        if ( userDao.queryUserByUsernameAndPassword("admin","admin1234") == null) {
            System.out.println("用户名或密码错误，登录失败");
        } else {
            System.out.println("查询成功");
        }
    }

    @Test
    public void saveUser() { //保存操作
        System.out.println( userDao.saveUser(new User(null,"wzg168", "123456", "wzg168@qq.com")) );
    }
}
```

### 6、编写UserService和测试

#### 1、UserService接口

```java
package com.atguigu.service;

import com.atguigu.pojo.User;

public interface UserService {
    /**
     * 注册用户
     * @param user
     */
    public void registerUser(User user);

    /**
     * 登录
     * @param user
     * @return 如果返回null，说明登录失败，返回有值，是登录成功
     */
    public User login(User user);

    /**
     * 检查 用户名是否可用
     * @param username
     * @return 返回true表示用户名已存在，返回false表示用户名可用
     */
    public boolean existsUsername(String username);
}

```

#### 2、UserService实现类

```java
package com.atguigu.service.impl;

import com.atguigu.dao.UserDao;
import com.atguigu.dao.impl.UserDaoImpl;
import com.atguigu.pojo.User;
import com.atguigu.service.UserService;

public class UserServiceImpl implements UserService {

    private UserDao userDao = new UserDaoImpl();

    @Override
    public void registerUser(User user) {
        userDao.saveUser(user);
    }

    @Override
    public User login(User user) {
        return userDao.queryUserByUsernameAndPassword(user.getUsername(), user.getPassword());
    }

    @Override
    public boolean existsUsername(String username) {

        if (userDao.queryUserByUsername(username) == null) {
           // 等于null,说明没查到，没查到表示可用
           return false;
        }

        return true;

    }
}

```

#### 3、UserServiceTest测试类

```java
package com.atguigu.test;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;
import org.junit.Test;

import static org.junit.Assert.*;

public class UserServiceTest {

    UserService userService = new UserServiceImpl();

    @Test
    public void registerUser() {
        userService.registerUser(new User(null, "bbj168", "666666", "bbj168@qq.com"));
        userService.registerUser(new User(null, "abc168", "666666", "abc168@qq.com"));
    }

    @Test
    public void login() {
        System.out.println( userService.login(new User(null, "wzg168", "123456", null)) );
    }

    @Test
    public void existsUsername() {
        if (userService.existsUsername("wzg16888")) {
            System.out.println("用户名已存在！");
        } else {
            System.out.println("用户名可用！");
        }
    }
}
```

### 7、编写Web层

> 用户注册和登陆的具体需求

```markdown
用户注册和登陆的实现。
	需求 1 ：用户注册
        需求如下：
        1）访问注册页面
        2）填写注册信息，提交给服务器
        3）服务器应该保存用户
        4）当用户已经存在--提示用户注册失败，用户名已存在
        5）当用户不存在-----注册成功
	需求 2 ：用户登陆
        需求如下：
        1）访问登陆页面
        2）填写用户名密码后提交
        3）服务器判断用户是否存在
        4）如果登陆失败 --->>>>返回用户名或者密码错误信息
        5）如果登录成功 --->>>> 返回登陆成功 信息
```



#### 1、图解用户注册流程

![image-20211122222427211](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211122222427211.png)

#### 2、修改regist.html和regist_success.html页面

![image-20211122222548286](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211122222548286.png)

#### 3、在src下web下编写RegistServlet程序

```java
package com.atguigu.web;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class RegistServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    //这个post请求就是为了在输入密码的时候，不被看见
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //  1、获取请求的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String email = req.getParameter("email");
        String code = req.getParameter("code");

//        2、检查 验证码是否正确  === 写死,要求验证码为:abcde
        if ("abcde".equalsIgnoreCase(code)) {
//        3、检查 用户名是否可用
            if (userService.existsUsername(username)) {
                System.out.println("用户名[" + username + "]已存在!");
//        跳回注册页面
                req.getRequestDispatcher("/pages/user/regist.html").forward(req, resp);
            } else {
                //      可用
//                调用Sservice保存到数据库
                userService.registerUser(new User(null, username, password, email));
//
//        跳到注册成功页面 regist_success.html
                req.getRequestDispatcher("/pages/user/regist_success.html").forward(req, resp);
            }
        } else {
            System.out.println("验证码[" + code + "]错误");
            req.getRequestDispatcher("/pages/user/regist.html").forward(req, resp);
        }
    }
}

```



#### 4、IDEA中的Debug调试的使用

> 1、Debug 点 调试代码，首先需要两个元素：断点 + Debug 

1、断点，只需要在代码需要停的行的左边上单击，就可以添加和取消

2、Debug 启动 Tomcat 运行代码：

![image-20211203181649223](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181649223.png)

3、测试工具栏

![image-20211203181717318](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181717318.png)

![image-20211203181725860](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181725860.png)

4、变量窗口：它可以查看当前方法范围内所有的有效的变量

![image-20211203181818503](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181818503.png)

5、方法调用栈窗口

```markdown
1、方法调用栈可以查看当前线程有哪些方法调用信息
2、下面的调用上一行的方法
```

![image-20211203181922571](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181922571.png)

其它常用调试相关按钮

![image-20211203181951341](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203181951341.png)

#### 5、用户登录功能实现

> 图解用户登陆

![image-20211203183322468](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203183322468.png)

> 修改 login.html  页面和 login_success.html 

修改base标签

![image-20211203183401863](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203183401863.png)

![image-20211203183413124](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211203183413124.png)

> 编写LoginServlet程序

```java
package com.atguigu.web;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class LoginServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //  1、获取请求的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        // 调用 userService.login()登录处理业务
        User loginUser = userService.login(new User(null, username, password, null));
        // 如果等于null,说明登录 失败!
        if (loginUser == null) {
            //   跳回登录页面
            req.getRequestDispatcher("/pages/user/login.html").forward(req, resp);
        } else {
            // 登录 成功
            //跳到成功页面login_success.html
            req.getRequestDispatcher("/pages/user/login_success.html").forward(req, resp);
        }
    }
}

```





## 3、书城优化

### 1、页面jsp动态化

```markdown
	1、在 html 页面顶行添加 page 指令。

	2、修改文件后缀名为：.jsp

	3、使用 IDEA 搜索替换.html 为.jsp(快捷键：Ctrl+Shift+R)
	
	4、也把浏览器上的缓存给清理掉，ctrl + shfit + delete
```

![image-20211204213014516](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211204213014516.png)

### 2、抽取页面中相同的内容

> head中的css、jquery、base标签

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
    String basePath = request.getScheme() //他是获取http协议
            + "://"
            + request.getServerName() //获取服务器名字，这样保证自己用自己主机号登陆，别人也能访问到
            + ":"
            + request.getServerPort() //获取端口号
            + request.getContextPath()//获取工程名称
            + "/";//这最后的/是不能省略的
%>

<!--写base标签，永远固定相对路径跳转的结果，动态base标签，而不是静态的-->
<base href="<%=basePath%>">
<link type="text/css" rel="stylesheet" href="static/css/style.css" >
<script type="text/javascript" src="static/script/jquery-1.7.2.js"></script>
```



每个页面的页脚

```jsp
<div id="bottom">
    <span>
    	尚硅谷书城.Copyright &copy;2015
    </span>
</div>
```

登录成功后的菜单

```jsp
<div>
    <span>欢迎<span class="um_span">韩总</span>光临尚硅谷书城</span>
    <a href="../order/order.jsp">我的订单</a>
    <a href="../../index.jsp">注销</a>&nbsp;&nbsp;
    <a href="../../index.jsp">返回</a>
</div>
```

manage模块的菜单

```jsp
<div>
    <a href="book_manager.jsp">图书管理</a>
    <a href="order_manager.jsp">订单管理</a>
    <a href="../../index.jsp">返回商城</a>
</div>
```

### 3、登录，注册错误提示，以及表单回显

当用户名或者密码错误是，能够在登陆或者注册页面显示提示信息，并且能够让输入过的姓名、邮箱输入出错后能够回显，而不需要再次输入

> 以登录回显为示例：
>
> ​	Servlet 程序端需要添加回显信息到 Request 域中

![image-20211205151256624](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205151256624.png)

在RegistServlet.java中把出错的提示信息放到request域中

```java
package com.atguigu.web;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class RegistServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    //这个post请求就是为了在输入密码的时候，不被看见
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        System.out.println("post开始启动了------");
        String username = req.getParameter("username");//  1、获取请求的参数
        //System.out.println(username);
        String password = req.getParameter("password");
        String email = req.getParameter("email");
        String code = req.getParameter("code");
        //System.out.println(code);
        if ("abcde".equalsIgnoreCase(code)) {//        2、检查 验证码是否正确  === 写死,要求验证码为:abcde
            //        3、检查 用户名是否可用
            if (userService.existsUsername(username)) {
                System.out.println("用户名[" + username + "]已存在!");
                // 把回显信息，保存到Request域中
                req.setAttribute("msg", "用户名已存在！！");
                req.setAttribute("username", username);
                req.setAttribute("email", email);
                //        跳回注册页面，不可用
                req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
            } else {
                //      可用
                //                调用Sservice保存到数据库
                userService.registerUser(new User(null, username, password, email));
                //        跳到注册成功页面 regist_success.html
                req.getRequestDispatcher("/pages/user/regist_success.jsp").forward(req, resp);
            }
        } else {
            //把回显信息，保存到Request域中
            req.setAttribute("msg", "验证码错误！！");
            req.setAttribute("username", username);
            req.setAttribute("email", email);

            System.out.println("验证码[" + code + "]错误");
            req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
        }
    }
}

```

loginServlet也是同样的道理

```java
package com.atguigu.web;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class LoginServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //  1、获取请求的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        // 调用 userService.login()登录处理业务
        User loginUser = userService.login(new User(null, username, password, null));
        // 如果等于null,说明登录 失败!
        if (loginUser == null) {
            //登陆失败的话，把错误的信息和回显的信息存储到request表单域中
            req.setAttribute("msg","用户名或密码输入错误");//提示信息
            req.setAttribute("username",username);//把输入的信息回显到提示栏中


            //   跳回登录页面
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req, resp);
        } else {
            // 登录 成功
            //跳到成功页面login_success.html
            req.getRequestDispatcher("/pages/user/login_success.jsp").forward(req, resp);
        }
    }
}

```

在这两个对象的jsp动态页面上把回显的value的值加上去

```jsp
<!--regist.jsp-->
<h1>注册尚硅谷会员</h1>
						<span class="errorMsg">
							<%=request.getAttribute("msg")==null?"":request.getAttribute("msg")%>
						</span>

<label>用户名称：</label>
							<input class="itxt" type="text" placeholder="请输入用户名"
								   value="<%=request.getAttribute("username")==null?"":request.getAttribute("username")%>"
								   autocomplete="off" tabindex="1" name="username" id="username" />
							<br />

<input class="itxt" type="text" placeholder="请输入邮箱地址"
								   value="<%=request.getAttribute("email")==null?"":request.getAttribute("email")%>"
								   autocomplete="off" tabindex="1" name="email" id="email" />
							<br />


<!--login.jsp-->
<div class="msg_cont">
								<b></b>
								<span class="errorMsg">
									<%=request.getAttribute("msg")==null?"请输入用户名和密码":request.getAttribute("msg")%>
								</span>
							</div>

<label>用户名称：</label>
									<input class="itxt" type="text" placeholder="请输入用户名" autocomplete="off" tabindex="1"
										   name="username" value="<%=request.getAttribute("username")==null?"":request.getAttribute("username")%>"/> <!--登陆的错误回显用户名-->
									<br />
```

### 4、BaseServlet的抽取

在实际的项目开发中，一个模块，一般只使用一个 Servlet 程序。

> 代码优化一： ： 代码优化： ：并 合并 LoginServlet 和 和 RegistServlet  程序为 UserServlet 

![image-20211205155112172](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205155112172.png)

UserServlet.java

```java
//分发请求
package com.atguigu.web;

import com.atguigu.pojo.User;
import com.atguigu.service.UserService;
import com.atguigu.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class UserServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();
    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("login请求被激活了");
        //  1、获取请求的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        // 调用 userService.login()登录处理业务
        User loginUser = userService.login(new User(null, username, password, null));
        // 如果等于null,说明登录 失败!
        if (loginUser == null) {
            //登陆失败的话，把错误的信息和回显的信息存储到request表单域中
            req.setAttribute("msg","用户名或密码输入错误");//提示信息
            req.setAttribute("username",username);//把输入的信息回显到提示栏中


            //   跳回登录页面
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req, resp);
        } else {
            // 登录 成功
            //跳到成功页面login_success.html
            req.getRequestDispatcher("/pages/user/login_success.jsp").forward(req, resp);
        }
    }


    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("regist请求 开始启动了------");
        String username = req.getParameter("username");//  1、获取请求的参数
        //System.out.println(username);
        String password = req.getParameter("password");
        String email = req.getParameter("email");
        String code = req.getParameter("code");
        //System.out.println(code);
        if ("abcde".equalsIgnoreCase(code)) {//        2、检查 验证码是否正确  === 写死,要求验证码为:abcde
            //        3、检查 用户名是否可用
            if (userService.existsUsername(username)) {
                System.out.println("用户名[" + username + "]已存在!");
                // 把回显信息，保存到Request域中
                req.setAttribute("msg", "用户名已存在！！");
                req.setAttribute("username", username);
                req.setAttribute("email", email);
                //        跳回注册页面，不可用
                req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
            } else {
                //      可用
                //                调用Sservice保存到数据库
                userService.registerUser(new User(null, username, password, email));
                //        跳到注册成功页面 regist_success.html
                req.getRequestDispatcher("/pages/user/regist_success.jsp").forward(req, resp);
            }
        } else {
            //把回显信息，保存到Request域中
            req.setAttribute("msg", "验证码错误！！");
            req.setAttribute("username", username);
            req.setAttribute("email", email);

            System.out.println("验证码[" + code + "]错误");
            req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
        }
    }

    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String action = req.getParameter("action");//通过隐式域来获取是那个页面的请求
        if("login".equals(action)){
            login(req,resp);
            System.out.println("处理登录请求");
        }else{
            regist(req,resp);
            System.out.println("处理注册请求");
        }
    }
}

```

修改配置信息

```xml
<servlet>
        <servlet-name>userServlet</servlet-name>
        <servlet-class>com.atguigu.web.UserServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>userServlet</servlet-name>
        <url-pattern>/userServlet</url-pattern>
    </servlet-mapping>
```

同时loginServlet和registServlet没事什么用了，把他们的xml中的配置信息可以注释掉了

### 5、利用反射优化大量if..else

> 目的：以后不用一添加一个功能就加入一个if..else

在UserServlet中优化利用反射来if else代码

```java
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String action = req.getParameter("action");//通过隐式域来获取是那个页面的请求
        // 获取 action 业务鉴别字符串，获取相应的业务 方法反射对象
        try{
            Method method = this.getClass().getDeclaredMethod(action,HttpServletRequest.class,HttpServletResponse.class);
            //System.out.println(method);
            //掉哦那个目标业务 方法
            method.invoke(this,req,resp);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
```

避免出现以下的情况

![image-20211205165511134](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205165511134.png)

### 6、抽取BaseSevlet程序

> 为何要抽取BaseServlet程序

![image-20211205165932115](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205165932115.png)

第一步，把UserServlet中的doPost()方法剪切掉

第二部，创建一个父类的BaseServlet,它继承HttpServlet,并把doPost()方法放进其中

```java
package com.atguigu.web;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.lang.reflect.Method;

public  abstract class BaseServlet extends HttpServlet { //父类，目的是为了代码复用
    //父类继承HttpServlet,而子类继承BaseServlet
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String action = req.getParameter("action");//通过隐式域来获取是那个页面的请求
        // 获取 action 业务鉴别字符串，获取相应的业务 方法反射对象
        try{
            Method method = this.getClass().getDeclaredMethod(action,HttpServletRequest.class,HttpServletResponse.class);
            //System.out.println(method);
            //掉哦那个目标业务 方法
            method.invoke(this,req,resp);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

```

### 7、数据的封装和抽取BeanUtils的使用

```markdown
	
	1、BeanUtils 工具类，它可以一次性的把所有请求的参数注入到 JavaBean 中。
	
	2、BeanUtils 工具类，经常用于把 Map 中的值注入到 JavaBean 中，或者是对象属性值的拷贝操作。

	3、BeanUtils 它不是 Jdk 的类。而是第三方的工具类。所以需要导包。
        1、导入需要的 jar 包：（beanutils依赖于loggin包）
        commons-beanutils-1.8.0.jar
        commons-logging-1.1.1.jar
        2、编写 WebUtils 工具类使用：
```

WebUtils工具类

```java
package com.atguigu.utils;

import org.apache.commons.beanutils.BeanUtils;

import java.util.Map;

public class WebUtils {
    /**
     * Map中的key 是对应的请求参数的变量名，value是从页面填写的值
     * 把Map中的值注入到对应的JavaBean属性中。
     * @param value
     * @param bean
     */
    public static <T> T copyParamToBean( Map value , T bean ){ //泛型的作用是省去了强制类型转化（对对象来说，不用强转，是代码更简洁），
        try {
            System.out.println("注入之前：" + bean);
            /**
             * 把所有请求的参数都注入到user对象中，user实质是javaBean对象,这样就省去了在Servlet的java代码中获取请求信息
             */
            BeanUtils.populate(bean, value);
            System.out.println("注入之后：" + bean);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bean;
    }

}

```



## 4、使用EL表达式修改表单回显



![image-20211205181142807](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205181142807.png)

## 5、图书模块

### MVC概念

```markdown
	1、MVC 全称：Model 模型、 View 视图、 Controller 控制器。

	2、MVC 最早出现在 JavaEE 三层中的 Web 层，它可以有效的指导 Web 层的代码如何有效分离，单独工作。

	3、View 视图：只负责数据和界面的显示，不接受任何与显示数据无关的代码，便于程序员和美工的分工合作——JSP/HTML。

	4、Controller 控制器：只负责接收请求，调用业务层的代码处理请求，然后派发页面，是一个“调度者”的角色——Servlet。转到某个页面。或者是重定向到某个页面。

	5、Model 模型：将与业务逻辑相关的数据封装为具体的 JavaBean 类，其中不掺杂任何与数据处理相关的代码-JavaBean/domain/entity/pojo。

	6、MVC  是一种思想MVC 的理念是将软件代码拆分成为组件，单独开发，组合使用（ 目的还是为了降低耦合度）。
```

![image-20211205181717022](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205181717022.png)

> MVC 的作用还是为了降低耦合。让代码合理分层。方便后期升级和维护。

### 1、图书模块

#### 1.1、编写图书模块的数据库表

创建图书表

```sql
##创建图书表
create table t_book(
	`id` int(11) primary key auto_increment, 	## 主键
	`name` varchar(50) not null,				## 书名 
	`author` varchar(50) not null,				## 作者
	`price` decimal(11,2) not null,				## 价格
	`sales` int(11) not null,					## 销量
	`stock` int(11) not null,					## 库存
	`img_path` varchar(200) not null			## 书的图片路径
);
```

插入初始数化测试数据

```mysql
## 插入初始化测试数据
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'java从入门到放弃' , '国哥' , 80 , 9999 , 9 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '数据结构与算法' , '严敏君' , 78.5 , 6 , 13 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '怎样拐跑别人的媳妇' , '龙伍' , 68, 99999 , 52 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '木虚肉盖饭' , '小胖' , 16, 1000 , 50 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'C++编程思想' , '刚哥' , 45.5 , 14 , 95 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '蛋炒饭' , '周星星' , 9.9, 12 , 53 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '赌神' , '龙伍' , 66.5, 125 , 535 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'Java编程思想' , '阳哥' , 99.5 , 47 , 36 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'JavaScript从入门到精通' , '婷姐' , 9.9 , 85 , 95 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'cocos2d-x游戏编程入门' , '国哥' , 49, 52 , 62 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'C语言程序设计' , '谭浩强' , 28 , 52 , 74 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'Lua语言程序设计' , '雷丰阳' , 51.5 , 48 , 82 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '西游记' , '罗贯中' , 12, 19 , 9999 , 'static/img/default.jpg');

insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '水浒传' , '华仔' , 33.05 , 22 , 88 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '操作系统原理' , '刘优' , 133.05 , 122 , 188 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '数据结构 java版' , '封大神' , 173.15 , 21 , 81 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'UNIX高级环境编程' , '乐天' , 99.15 , 210 , 810 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , 'javaScript高级编程' , '国哥' , 69.15 , 210 , 810 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '大话设计模式' , '国哥' , 89.15 , 20 , 10 , 'static/img/default.jpg');
 
insert into t_book(`id` , `name` , `author` , `price` , `sales` , `stock` , `img_path`) 
values(null , '人月神话' , '刚哥' , 88.15 , 20 , 80 , 'static/img/default.jpg');
```

查看表的内容

```mysql
## 查看表内容
select id,name,author,price,sales,stock,img_path from t_book;
```



#### 1.2、编写图书模块的JavaBean

```java
package com.atguigu.pojo;

import java.math.BigDecimal;

public class Book {
    private Integer id;
    private String name;
    private String author;
    private BigDecimal price;
    private Integer sales;
    private Integer stock;
    private String imgPath = "static/img/default.jpg";

    public Book() {
    }

    public Book(Integer id, String name, String author, BigDecimal price, Integer sales, Integer stock, String imgPath) {
        this.id = id;
        this.name = name;
        this.author = author;
        this.price = price;
        this.sales = sales;
        this.stock = stock;
        // 要求给定的图书封面图书路径不能为空
        if (imgPath != null && !"".equals(imgPath)) {
            this.imgPath = imgPath;
        }

    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getSales() {
        return sales;
    }

    public void setSales(Integer sales) {
        this.sales = sales;
    }

    public Integer getStock() {
        return stock;
    }

    public void setStock(Integer stock) {
        this.stock = stock;
    }

    public String getImgPath() {
        return imgPath;
    }

    public void setImgPath(String imgPath) {
        // 要求给定的图书封面图书路径不能为空
        if (imgPath != null && !"".equals(imgPath)) {
            this.imgPath = imgPath;
        }
    }


    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                ", sales=" + sales +
                ", stock=" + stock +
                ", imgPath='" + imgPath + '\'' +
                '}';
    }
}

```

#### 1.3、编写图书模块的Dao和测试Dao

> Dao层主要是和数据库做交互

BookDao主要是实现书的增删改查

Dao接口

```java
package com.atguigu.dao;

import com.atguigu.pojo.Book;
import java.util.List;

public interface BookDao { //主要是接口

    public int addBook(Book book);

    public int deleteBookById(Integer id);

    public int updateBook(Book book);

    public Book queryBookById(Integer id);

    public List<Book> queryBooks();

}

```

BookDaoImpl实现类

```java
package com.atguigu.dao.impl;

import com.atguigu.dao.BookDao;
import com.atguigu.pojo.Book;

import java.util.List;

public class BookDaoImpl extends BaseDao implements BookDao { //接口的实现，去完成增，删，改，查
    @Override
    public int addBook(Book book) { //增加

        String sql = "insert into t_book(`name`,`author`,`price`,`sales`,`stock`,`img_path`) values(?,?,?,?,?,?)";

        return update(sql, book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath());

    }

    @Override
    public int deleteBookById(Integer id) { //删除
        String sql = "delete from t_book where id = ?";
        return update(sql, id);
    }

    @Override
    public int updateBook(Book book) { //更新
        String sql = "update t_book set `name`=?,`author`=?,`price`=?,`sales`=?,`stock`=?,`img_path`=? where id = ?";
        return update(sql,book.getName(),book.getAuthor(),book.getPrice(),book.getSales(),book.getStock(),book.getImgPath(),book.getId());
    }

    @Override
    public Book queryBookById(Integer id) { //查询（按照ID）
        String sql = "select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` imgPath from t_book where id = ?";
        return queryForOne(Book.class, sql,id);
    }

    @Override
    public List<Book> queryBooks() { //查询所有的图书
        String sql = "select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` imgPath from t_book";
        return queryForList(Book.class, sql);
    }
}

```

BookDao的测试

```java
package com.atguigu.test;

import com.atguigu.dao.BookDao;
import com.atguigu.dao.impl.BookDaoImpl;
import com.atguigu.pojo.Book;
import org.junit.Test;

import java.math.BigDecimal;

import static org.junit.Assert.*;

public class BookDaoTest {

    private BookDao bookDao = new BookDaoImpl();

    @Test
    public void addBook() {
        bookDao.addBook(new Book(null,"国哥为什么这么帅！", "191125", new BigDecimal(9999),1100000,0,null
                ));
    }

    @Test
    public void deleteBookById() {
        bookDao.deleteBookById(21);
    }

    @Test
    public void updateBook() {
        bookDao.updateBook(new Book(21,"大家都可以这么帅！", "国哥", new BigDecimal(9999),1100000,0,null
        ));
    }

    @Test
    public void queryBookById() {
        System.out.println( bookDao.queryBookById(21) );
    }

    @Test
    public void queryBooks() {
        for (Book queryBook : bookDao.queryBooks()) {
            System.out.println(queryBook);
        }
    }
}
```

#### 1.4、编写图书模块的 Service  和测试 Service

> 主要是桥梁，把Dao层和javaBean层给连接起来，并添加各种各样的服务

BookService接口

```java
package com.atguigu.service;

import com.atguigu.pojo.Book;

import java.util.List;

public interface BookService {

    public void addBook(Book book);

    public void deleteBookById(Integer id);

    public void updateBook(Book book);

    public Book queryBookById(Integer id);

    public List<Book> queryBooks();

}
```

BookServiceImpl实现类

```java
package com.atguigu.service.impl;

import com.atguigu.dao.BookDao;
import com.atguigu.dao.impl.BookDaoImpl;
import com.atguigu.pojo.Book;
import com.atguigu.service.BookService;

import java.util.List;

public class BookServiceImpl implements BookService {

    private BookDao bookDao = new BookDaoImpl();

    @Override
    public void addBook(Book book) {
        bookDao.addBook(book);
    }

    @Override
    public void deleteBookById(Integer id) {
        bookDao.deleteBookById(id);
    }

    @Override
    public void updateBook(Book book) {
        bookDao.updateBook(book);
    }

    @Override
    public Book queryBookById(Integer id) {
        return bookDao.queryBookById(id);
    }

    @Override
    public List<Book> queryBooks() {
        return bookDao.queryBooks();
    }
}
```

BookService的测试

```java
package com.atguigu.test;

import com.atguigu.pojo.Book;
import com.atguigu.service.BookService;
import com.atguigu.service.impl.BookServiceImpl;
import org.junit.Test;

import java.math.BigDecimal;

import static org.junit.Assert.*;

public class BookServiceTest {

    private BookService bookService = new BookServiceImpl();

    @Test
    public void addBook() {
        bookService.addBook(new Book(null,"国哥在手，天下我有！", "1125", new BigDecimal(1000000), 100000000, 0, null));
    }

    @Test
    public void deleteBookById() {
        bookService.deleteBookById(22);
    }

    @Test
    public void updateBook() {
        bookService.updateBook(new Book(22,"社会我国哥，人狠话不多！", "1125", new BigDecimal(999999), 10, 111110, null));
    }

    @Test
    public void queryBookById() {
        System.out.println(bookService.queryBookById(22));
    }

    @Test
    public void queryBooks() {
        for (Book queryBook : bookService.queryBooks()) {
            System.out.println(queryBook);
        }
    }
}
```

#### 1.5、编写图书模块的 Web 层，和页面联调测试

##### 1、图解列表功能流程以及实现：

![image-20211205192619629](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205192619629.png)



###### 1、BookServlet程序添加list方法

```java
public class BookServlet extends BaseServlet{

    private BookService bookService = new BookServiceImpl();
    
    protected void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 通过BookService查询全部图书
        List<Book> books = bookService.queryBooks();
        //2 把全部图书保存到Request域中
        req.setAttribute("books", books);
        //3、请求转发到/pages/manager/book_manager.jsp页面
        req.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(req,resp);
    }
    
}
```

###### 2、配置xml

![image-20211205193932808](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205193932808.png)

###### 3、修改图书管理请求地址

![image-20211205194208950](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205194208950.png)

###### 5、增加两个jar包，以方便调用JSTL标签来实现foreach

```markdown
taglibs-standard-impl-1.2.1.jar
taglibs-standard-spec-1.2.1.jar
```

###### 6、修改pages/manager/book_manager.jsp页面的数据遍历输出

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
	<title>图书管理</title>
	<%@ include file="/pages/common/head.jsp"%>
</head>
<body>
	
	<div id="header">
			<img class="logo_img" alt="" src="static/img/logo.gif" >
			<span class="wel_word">图书管理系统</span>
			<%@ include file="/pages/common/manager_menu.jsp"%>
	</div>
	
	<div id="main">
		<table>
			<tr>
				<td>名称</td>
				<td>价格</td>
				<td>作者</td>
				<td>销量</td>
				<td>库存</td>
				<td colspan="2">操作</td>
			</tr>		
			<c:forEach items="${requestScope.books}" var="book">  <%--这里的books一定要与提交的list中的key保持一致--%>
				<tr>
					<td>${book.name}</td>
					<td>${book.price}</td>
					<td>${book.author}</td>
					<td>${book.sales}</td>
					<td>${book.stock}</td>
					<td><a href="book_edit.jsp">修改</a></td>
					<td><a href="#">删除</a></td>
				</tr>
			</c:forEach>

			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td><a href="book_edit.jsp">添加图书</a></td>
			</tr>	
		</table>
	</div>

	<%@ include file="/pages/common/footer.jsp"%>
</body>
</html>
```

###### 6、访问图示列表正确的方式

> 后台管理-> 图书馆理  

注意：不能直接去点用图书馆

###### 7、给BookServlet增加doget方法，并调用dopost

```java
@Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req,resp);
    }
```

##### 2、前后台的简单介绍

![image-20211205201730993](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205201730993.png)

##### 3、添加图书功能的实现

###### 1、添加图书流程细节

![image-20211205202535607](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205202535607.png)

###### 2、问题说明：表单重复提交

当用户提交完请求，浏览器会记录下最后一次请求的全部信息。当用户按下功能键 F5，就会发起浏览器记录的最后一次请求。

所以，在add在跳转页面的方式为重定向而不是转发，一转发就再次执行了添加图书的功能，

###### 3、BookServlet程序添加add方法

```java
protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //        1、获取请求的参数==封装成为Book对象
        Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());
//        2、调用BookService.addBook()保存图书
        bookService.addBook(book);
//        3、跳到图书列表页面
//                /manager/bookServlet?action=list
//        req.getRequestDispatcher("/manager/bookServlet?action=list").forward(req, resp);

        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=list");

    }
```

修改book_edit.jsp页面

![image-20211205211647579](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205211647579.png)



##### 4、删除图书功能的实现

###### 1、图解删除流程

![image-20211205212042751](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205212042751.png)

###### 2、BookServlet程序中的delete方法：

```java
//查出，并提交到list
    protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        1、获取请求的参数id，图书编程
        int id = WebUtils.parseInt(req.getParameter("id"), 0);
//        2、调用bookService.deleteBookById();删除图书
        bookService.deleteBookById(id);
//        3、重定向回图书列表管理页面
//                /book/manager/bookServlet?action=list
        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=list");
    }
```

###### 3、 给 WebUtils  工具类添加转换 int

```java
//将String类型的id,转换成int类型的id
    public static int parseInt(String id, int i) {
        try{
            return Integer.parseInt(id);
        }catch (Exception e){
            e.printStackTrace();
        }
        return i;
    }
```



 ###### 4、修改删除的连接地址

> a class=“deleteClass”是标签选择器，用于javascript获得此标签使用

![image-20211205213938335](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205213938335.png)

###### 5、给删除添加确认提示操作

> 目的是，用户不小心提交了删除按钮，可以发出提示

```jsp
<script type="text/javascript">
		$(function () {
			// 给删除的a标签绑定单击事件，用于删除的确认提示操作
			$("a.deleteClass").click(function () {
				// 在事件的function函数中，有一个this对象。这个this对象，是当前正在响应事件的dom对象。
				/**
				 * confirm是确认提示框函数
				 * 参数是它的提示内容
				 * 它有两个按钮，一个确认，一个是取消。
				 * 返回true表示点击了，确认，返回false表示点击取消。
				 */
				return confirm("你确定要删除【" + $(this).parent().parent().find("td:first").text() + "】?");
				// return false// 阻止元素的默认行为===不提交请求
			});
		});
	</script>
```

##### 5、修改图书功能的实现

###### 1、图解修改图书的细节

![image-20211205220937519](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205220937519.png)



###### 2、更新【修改】的请求地址：

![image-20211205221011602](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205221011602.png)



###### 3、BookServlet  程序中添加 getBook  方法

```java
//从数据库库中获取修改图书信息get方法
    protected void getBook(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 获取请求的参数图书编号
        int id = WebUtils.parseInt(req.getParameter("id"), 0);
        //2 调用bookService.queryBookById查询图书
        Book book = bookService.queryBookById(id);
        //3 保存到图书到Request域中
        req.setAttribute("book", book) ;
        //4 请求转发到。pages/manager/book_edit.jsp页面
        req.getRequestDispatcher("/pages/manager/book_edit.jsp").forward(req,resp);
    }
```

###### 4、在 book_edit.jsp 页面中显示修改的数据

![image-20211205222025435](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205222025435.png)

###### 5、在BookServlet程序中添加update方法

```java
protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        1、获取请求的参数==封装成为Book对象
        Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());
//        2、调用BookService.updateBook( book );修改图书
        bookService.updateBook(book);
//        3、重定向回图书列表管理页面
//        地址：/工程名/manager/bookServlet?action=list
        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=list");
    }
```

###### 6、解决book_edit.jsp页面，既要添加，又要实现修改操作

> 难点：不知道value的值是add,还是update,
>
> 这个参数的动态获取方法

![image-20211205222355766](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211205222355766.png)



### 2、图书分页

#### 1、分页模块的分析

![image-20211206095855139](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206095855139.png)

##### 1、分页模型的page（Javabean）

```java
package com.atguigu.pojo;

import java.util.List;

/**
 * Page是分页的模型对象
 * @param <T> 是具体的模块的javaBean类
 */
public class Page<T> {
    //默认显示总数为4
    public static final Integer PAGE_SIZE = 4;
    // 当前页码
    private Integer pageNo;
    // 总页码
    private Integer pageTotal;
    // 当前页显示数量
    private Integer pageSize = PAGE_SIZE;
    // 总记录数
    private Integer pageTotalCount;
    // 当前页数据 打包到items中
    private List<T> items;
    // 分页条的请求地址
    private String url;

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public Integer getPageNo() {
        return pageNo;
    }

    public void setPageNo(Integer pageNo) {
        /* 数据边界的有效检查 */
        if (pageNo < 1) {
            pageNo = 1;
        }
        if (pageNo > pageTotal) {
            pageNo = pageTotal;
        }

        this.pageNo = pageNo;
    }

    public Integer getPageTotal() {
        return pageTotal;
    }

    public void setPageTotal(Integer pageTotal) {
        this.pageTotal = pageTotal;
    }

    public Integer getPageSize() {
        return pageSize;
    }

    public void setPageSize(Integer pageSize) {
        this.pageSize = pageSize;
    }

    public Integer getPageTotalCount() {
        return pageTotalCount;
    }

    public void setPageTotalCount(Integer pageTotalCount) {
        this.pageTotalCount = pageTotalCount;
    }

    public List<T> getItems() {
        return items;
    }

    public void setItems(List<T> items) {
        this.items = items;
    }

    @Override
    public String toString() {
        return "Page{" +
                "pageNo=" + pageNo +
                ", pageTotal=" + pageTotal +
                ", pageSize=" + pageSize +
                ", pageTotalCount=" + pageTotalCount +
                ", items=" + items +
                ", url='" + url + '\'' +
                '}';
    }
}

```

##### 2、BookServlet程序的代码

```java
/**
     * 处理分页功能
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 获取请求的参数 pageNo 和 pageSize
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"), 1);
        int pageSize = WebUtils.parseInt(req.getParameter("pageSize"), Page.PAGE_SIZE);
        //2 调用BookService.page(pageNo，pageSize)：Page对象
        Page<Book> page = bookService.page(pageNo,pageSize);

        page.setUrl("manager/bookServlet?action=page");

        //3 保存Page对象到Request域中
        req.setAttribute("page",page);
        //4 请求转发到pages/manager/book_manager.jsp页面
        req.getRequestDispatcher("/pages/manager/book_manager.jsp").forward(req,resp);
    }
```

##### 3、BookServiceIpml代码

```java
//增加分页方法 public Page<Book> page(int pageNo, int pageSize)
@Override
    public Page<Book> page(int pageNo, int pageSize) {
        Page<Book> page = new Page<Book>();

        // 设置每页显示的数量
        page.setPageSize(pageSize);
        // 求总记录数
        Integer pageTotalCount = bookDao.queryForPageTotalCount();
        // 设置总记录数
        page.setPageTotalCount(pageTotalCount);
        // 求总页码
        Integer pageTotal = pageTotalCount / pageSize;
        if (pageTotalCount % pageSize > 0) {
            pageTotal+=1;
        }
        // 设置总页码
        page.setPageTotal(pageTotal);

        // 设置当前页码
        page.setPageNo(pageNo);

        // 求当前页数据的开始索引
        int begin = (page.getPageNo() - 1) * pageSize;
        // 求当前页数据
        List<Book> items = bookDao.queryForPageItems(begin,pageSize);
        // 设置当前页数据
        page.setItems(items);

        return page;
    }
```



##### 4、在BookDao层实现跟数据库的交互

```java
//首先在bookDao中实现两个接口，分别用于查书的总数，和当前页显示的数
Integer queryForPageTotalCount();

List<Book> queryForPageItems(int begin, int pageSize);

//通过接口实现类去实现它
 @Override
    public Integer queryForPageTotalCount() {
        String sql = "select count(*) from t_book";
        Number count = (Number) queryForSingleValue(sql);
        return count.intValue();
    }

    @Override
    public List<Book> queryForPageItems(int begin, int pageSize) {
        String sql = "select `id` , `name` , `author` , `price` , `sales` , `stock` , `img_path` imgPath from t_book limit ?,?";
        return queryForList(Book.class,sql,begin,pageSize);
    }
```

##### 5、manager_menu.jsp中的【图书管理】请求地址的修改

> 按照分页的方式提交

![image-20211206112746532](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206112746532.png)

##### 6、book_manager.jsp修改

![image-20211206113144175](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206113144175.png)

![image-20211206113203723](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206113203723.png)

##### 7、首页、上一页、下一页、末页实现

```jsp
<div id="page_nav">
			<%--大于首页，才显示--%>
			<c:if test="${requestScope.page.pageNo>1}">
				<a href="#">首页</a>
				<a href="#">上一页</a>
			</c:if>

            <a href="#">3</a>
            【${requestScope.page.pageNo}】 <%--当前页--%>
			<a href="#">5</a>
			<%--如果已经是最后一页，则不显示下一页，末页--%>
			<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotalCount}">
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}">下一页</a>
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageTotal}">末页</a>
			</c:if>


            共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录 到第<input value="4" name="pn" id="pn_input"/>页
            <input type="button" value="确定">
        </div>
```

##### 8、分页模块中跳转到指定页数功能实现

首先把工程路径放到域当中

![image-20211206165019559](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206165019559.png)

```jsp
到第<input value="4" name="pn" id="pn_input"/>页,
            <input id="searchPageBtn" type="button" value="确定">

			<%--想要在输入框中输入数字并条撞到相应的页数，就得给输入框绑定事件--%>
			<script type="text/javascript" >
				$(function () {
					//跳转到指定的页码
					$("#searchPageBtn").click(function () {
						var pageNo = $("#pn_input").val(); /*要跳转的页码*/
						var pageTotal = ${requestScope.page.pageTotal}; /*总页码*/
						if(pageNo < 1 || pageNo > pageTotal){
							alert("对不起，你想跳转的页面超出了本该有的限制");
						}else{
							// javaScript 语言中提供了一个 location 地址栏对象
							// 它有一个属性叫 href. 它可以获取浏览器地址栏中的地址
							// href 属性可读，可写
							location.href = "${pageScope.basePath}manager/bookServlet?action=page&pageNo=" + pageNo;
						}
					});
				});
			</script>
```

> 以上的功能是超出了跳转的容量，就是提示错误信息，接下来就是，超出限制，把其转为第一页或者最后一页

BookDao的方法修改

```java
public void setPageNo(Integer pageNo) {
        //以下代码放到这里的原因是，只要有分页界面都会用这个东西，所以放到这里提高代码复用
        //防止数据超出限制，这里给出合理区间，
        /* 数据边界的有效检查 */
        if (pageNo < 1) {
            pageNo = 1;
        }
        if (pageNo > pageTotal) {
            pageNo = pageTotal;
        }
        this.pageNo = pageNo;
    }
```

BookService中的page方法修改

![image-20211206171935976](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206171935976.png)

##### 9、分页模块中，页码1,2, 【3 】,4,5 的显示 的显示 ，要显示 要显示 5 个页 个页码，并且页码可以点击跳转。

> 需求：显示 5 个连续的页码，而且当前页码在中间。除了当前页码之外，每个页码都可以点击跳到指定页。

```markdown
# 1、如果总页码小于等于 5  的情况，页码的范围是：1 -- 总页码

	总页码1页 1
	总页码2 页 1，2
	总页码3 页 1，2，3
	总页码4 页 1，2，3，4
	总页码5 页 1，2，3，4，5
	
# 2、总页码大于 5  的情况。假设一共 10 页
	小情况 1 ：当前页码为前面 3  个：1 ，2 ，3  的情况，页码范围是：1 -- 5
		【1】2，3，4，5
		1【2】3，4，5
		1，2【3】4，5
	小情况 2 ：当前页码为最后 3  个，8 ，9 ，10 ，页码范围是：总页码减4  到  总页码
		6，7【8】9，10
		6，7，8【9】10
		6，7，8，9【10】
	小情况 3 ：4 ，5 ，6 ，7 ，页码范围是：当前页码减2  到  当前页码加2
		2，3，4，5，6
		3，4，5，6，7
		4，5，6，7，8
		5，6，7，8，9
```

```jsp
<%--大于首页，才显示--%>
			<c:if test="${requestScope.page.pageNo>1}">
				<a href="manager/bookServlet?action=page&pageNo=1">首页</a>
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo-1}">上一页</a>
			</c:if>

				<%-- 页码输出的开始 --%>
				<c:choose>
					<%-- 情况 1 ：如果总页码小于等于 5 的情况，页码的范围是： 1- 总页码 --%>
					<c:when test="${ requestScope.page.pageTotal <= 5 }">
						<c:set var="begin" value="1"/>  <%--为了防止伟哥判断语句都去遍历，这里只需要设置开始和结束标记就可以了，让最后的条件外的foreach输出即可--%>
						<c:set var="end" value="${requestScope.page.pageTotal}"/>
					</c:when>
					<%-- 情况 2 ：总页码大于 5 的情况 --%>
					<c:when test="${requestScope.page.pageTotal > 5}">
						<c:choose>
							<%-- 小情况 1 ：当前页码为前面 3 个： 1 ， 2 ， 3 的情况，页码范围是： 1-5.--%>
							<c:when test="${requestScope.page.pageNo <= 3}">
								<c:set var="begin" value="1"/>
								<c:set var="end" value="5"/>
							</c:when>
							<%-- 小情况 2 ：当前页码为最后 3 个， 8 ， 9 ， 10 ，页码范围是：总页码减 4 - 总页码 --%>
							<c:when test="${requestScope.page.pageNo > requestScope.page.pageTotal-3}">
								<c:set var="begin" value="${requestScope.page.pageTotal-4}"/>
								<c:set var="end" value="${requestScope.page.pageTotal}"/>
							</c:when>
							<%-- 小情况 3 ： 4 ， 5 ， 6 ， 7 ，页码范围是：当前页码减 2 - 当前页码加 2--%>
							<c:otherwise>
								<c:set var="begin" value="${requestScope.page.pageNo-2}"/>
								<c:set var="end" value="${requestScope.page.pageNo+2}"/>
							</c:otherwise>
						</c:choose>
					</c:when>
				</c:choose>
				<c:forEach begin="${begin}" end="${end}" var="i">
					<c:if test="${i == requestScope.page.pageNo}">  <%--当前页不可跳转，其它页可跳转--%>
						【${i}】
					</c:if>
					<c:if test="${i != requestScope.page.pageNo}">
						<a href="manager/bookServlet?action=page&pageNo=${i}">${i}</a>
					</c:if>
				</c:forEach>
				<%-- 页码输出的结束 --%>    
			<%--如果已经是最后一页，则不显示下一页，末页--%>
			<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotal}">
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}">下一页</a>
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageTotal}">末页</a>
			</c:if>

            共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录
			到第<input value="4" name="pn" id="pn_input"/>页,
            <input id="searchPageBtn" type="button" value="确定">
```

##### 10、修改分页后，增加，删除，修改图书信息的回显页面

以修改图书为示例：

###### 1、在修改的请求地址上追加上当前页码参数

![image-20211206180555278](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206180555278.png)

###### 2、在 book_edit.jsp 页面中使用隐藏域记录下 pageNo 参数

![image-20211206180625567](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206180625567.png)

> 这样方便修改的页面把送到Servlet中，并进行回显

###### 3、在服务器重定向的时候，获取当前页码追加上进行跳转

![image-20211206181319650](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206181319650.png)

整体修改好的BookServlet.java

```java
   protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        1、获取请求的参数==封装成为Book对象
        Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());
//        2、调用BookService.updateBook( book );修改图书
        bookService.updateBook(book);
//        3、重定向回图书列表管理页面
//        地址：/工程名/manager/bookServlet?action=list
        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=page&pageNo="+req.getParameter("pageNo"));
    }

protected void delete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//        1、获取请求的参数id，图书编程
        int id = WebUtils.parseInt(req.getParameter("id"), 0);
//        2、调用bookService.deleteBookById();删除图书
        bookService.deleteBookById(id);
//        3、重定向回图书列表管理页面
//                /book/manager/bookServlet?action=list
        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=page&pageNo="+req.getParameter("pageNo"));
    }

protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"),0);
        pageNo += 1;//通过自增，能让加一个书籍显示在最后一页中

        //        1、获取请求的参数==封装成为Book对象，送到对应的javaBean当中
        Book book = WebUtils.copyParamToBean(req.getParameterMap(),new Book());
//        2、调用BookService.addBook()保存图书,保存到数据库中
        bookService.addBook(book);
//        3、跳到图书列表页面
//                /manager/bookServlet?action=list
//        req.getRequestDispatcher("/manager/bookServlet?action=list").forward(req, resp);//如果要中这个的话，按住F5,会转发

        resp.sendRedirect(req.getContextPath() + "/manager/bookServlet?action=page&pageNo="+pageNo);

    }
```

### 3、首页index.jsp的跳转

> 想办法从默认的index.jsp跳转到默认的客户端的index下面

![image-20211206185133671](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206185133671.png)

#### 1、在web/pages下建立客户端文件夹client

#### 2、在client下建立相对应的index.jsp文件

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>书城首页</title>
	<%-- 静态包含 base标签、css样式、jQuery文件 --%>
	<%@ include file="/pages/common/head.jsp"%>

</head>
<body>
	
	<div id="header">
			<img class="logo_img" alt="" src="static/img/logo.gif" >
			<span class="wel_word">网上书城</span>
			<div>
				<a href="pages/user/login.jsp">登录</a> |
				<a href="pages/user/regist.jsp">注册</a> &nbsp;&nbsp;
				<a href="pages/cart/cart.jsp">购物车</a>
				<a href="pages/manager/manager.jsp">后台管理</a>
			</div>
	</div>

	<div id="main">
		<div id="book">
			<div class="book_cond">
				<form action="client/bookServlet" method="get">
					<input type="hidden" name="action" value="pageByPrice">
					价格：<input id="min" type="text" name="min" value="${param.min}"> 元 -
						<input id="max" type="text" name="max" value="${param.max}"> 元
						<input type="submit" value="查询" />
				</form>
			</div>
			<div style="text-align: center">
				<span>您的购物车中有3件商品</span>
				<div>
					您刚刚将<span style="color: red">时间简史</span>加入到了购物车中
				</div>
			</div>

			<c:forEach items="${requestScope.page.items}" var="book">
			<div class="b_list">
				<div class="img_div">
					<img class="book_img" alt="" src="${book.imgPath}" />
				</div>
				<div class="book_info">
					<div class="book_name">
						<span class="sp1">书名:</span>
						<span class="sp2">${book.name}</span>
					</div>
					<div class="book_author">
						<span class="sp1">作者:</span>
						<span class="sp2">${book.author}</span>
					</div>
					<div class="book_price">
						<span class="sp1">价格:</span>
						<span class="sp2">￥${book.price}</span>
					</div>
					<div class="book_sales">
						<span class="sp1">销量:</span>
						<span class="sp2">${book.sales}</span>
					</div>
					<div class="book_amount">
						<span class="sp1">库存:</span>
						<span class="sp2">${book.stock}</span>
					</div>
					<div class="book_add">
						<button>加入购物车</button>
					</div>
				</div>
			</div>
			</c:forEach>
		</div>

		<div id="page_nav">
			<%--大于首页，才显示--%>
			<c:if test="${requestScope.page.pageNo>1}">
				<a href="manager/bookServlet?action=page&pageNo=1">首页</a>
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo-1}">上一页</a>
			</c:if>

			<%-- 页码输出的开始 --%>
			<c:choose>
				<%-- 情况 1 ：如果总页码小于等于 5 的情况，页码的范围是： 1- 总页码 --%>
				<c:when test="${ requestScope.page.pageTotal <= 5 }">
					<c:set var="begin" value="1"/>  <%--为了防止伟哥判断语句都去遍历，这里只需要设置开始和结束标记就可以了，让最后的条件外的foreach输出即可--%>
					<c:set var="end" value="${requestScope.page.pageTotal}"/>
				</c:when>
				<%-- 情况 2 ：总页码大于 5 的情况 --%>
				<c:when test="${requestScope.page.pageTotal > 5}">
					<c:choose>
						<%-- 小情况 1 ：当前页码为前面 3 个： 1 ， 2 ， 3 的情况，页码范围是： 1-5.--%>
						<c:when test="${requestScope.page.pageNo <= 3}">
							<c:set var="begin" value="1"/>
							<c:set var="end" value="5"/>
						</c:when>
						<%-- 小情况 2 ：当前页码为最后 3 个， 8 ， 9 ， 10 ，页码范围是：总页码减 4 - 总页码 --%>
						<c:when test="${requestScope.page.pageNo > requestScope.page.pageTotal-3}">
							<c:set var="begin" value="${requestScope.page.pageTotal-4}"/>
							<c:set var="end" value="${requestScope.page.pageTotal}"/>
						</c:when>
						<%-- 小情况 3 ： 4 ， 5 ， 6 ， 7 ，页码范围是：当前页码减 2 - 当前页码加 2--%>
						<c:otherwise>
							<c:set var="begin" value="${requestScope.page.pageNo-2}"/>
							<c:set var="end" value="${requestScope.page.pageNo+2}"/>
						</c:otherwise>
					</c:choose>
				</c:when>
			</c:choose>
			<c:forEach begin="${begin}" end="${end}" var="i">
				<c:if test="${i == requestScope.page.pageNo}">  <%--当前页不可跳转，其它页可跳转--%>
					【${i}】
				</c:if>
				<c:if test="${i != requestScope.page.pageNo}">
					<a href="manager/bookServlet?action=page&pageNo=${i}">${i}</a>
				</c:if>
			</c:forEach>
			<%-- 页码输出的结束 --%>
			<%--如果已经是最后一页，则不显示下一页，末页--%>
			<c:if test="${requestScope.page.pageNo < requestScope.page.pageTotal}">
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageNo+1}">下一页</a>
				<a href="manager/bookServlet?action=page&pageNo=${requestScope.page.pageTotal}">末页</a>
			</c:if>

			共${requestScope.page.pageTotal}页，${requestScope.page.pageTotalCount}条记录
			到第<input value="4" name="pn" id="pn_input"/>页,
			<input id="searchPageBtn" type="button" value="确定">

			<%--想要在输入框中输入数字并条撞到相应的页数，就得给输入框绑定事件--%>
			<script type="text/javascript" >
				$(function () {
					//跳转到指定的页码
					$("#searchPageBtn").click(function () {
						var pageNo = $("#pn_input").val(); /*要跳转的页码*/
						var pageTotal = ${requestScope.page.pageTotal}; /*总页码*/
						if(pageNo < 1 || pageNo > pageTotal){
							alert("对不起，你想跳转的页面超出了本该有的限制,已经给您跳到范围的边界了");
						}else{
							// javaScript 语言中提供了一个 location 地址栏对象
							// 它有一个属性叫 href. 它可以获取浏览器地址栏中的地址
							// href 属性可读，可写
							location.href = "${pageScope.basePath}manager/bookServlet?action=page&pageNo=" + pageNo;
						}
					});
				});
			</script>
		</div>

	</div>

	<%--静态包含页脚内容--%>
	<%@include file="/pages/common/footer.jsp"%>

</body>
</html>
```



#### 3、在web层创建ClientBookServlet

必须得有page方法

```java
public class ClientBookServlet extends BaseServlet{
    private BookService bookService = new BookServiceImpl();

    /**
     * 处理分页功能
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void page(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 获取请求的参数 pageNo 和 pageSize
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"), 1);
        int pageSize = WebUtils.parseInt(req.getParameter("pageSize"), Page.PAGE_SIZE);
        //2 调用BookService.page(pageNo，pageSize)：Page对象
        Page<Book> page = bookService.page(pageNo,pageSize);
        page.setUrl("client/bookServlet?action=page");
        //3 保存Page对象到Request域中
        req.setAttribute("page",page);
        //4 请求转发到pages/manager/book_manager.jsp页面
        req.getRequestDispatcher("/pages/client/index.jsp").forward(req,resp);
    }
}

```

#### 4、配置xml信息

![image-20211206190707816](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206190707816.png)

#### 5、把web下的index内容清空，并通过指令装发到client下的index下

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%--只负责请求转发--%>
<jsp:forward page="/client/bookServlet?action=page"></jsp:forward>
```

#### 6、将client下的index中的manager/bookServlet全部换成client/bookServlet

ctrl+shift+r，搜索，替换

### 4、分页条的抽取

> 抽取分页条中请求地址为 url 变量
>
> 目的：方便前后台，分页条的抽取，不这样做的话url格式不一样，无法抽取分离

#### 1、在page（JavaBean）对象中添加url属性

```markdown
public String getUrl() { return url;}
```



#### 2、在ClientServlet程序的page分页方法中设置url的分页请求地址

![image-20211206193427266](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206193427266.png)



#### 3、在bookServlet程序中的page分页方法中设置url分页请求地址

![image-20211206193739252](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206193739252.png)

#### 4、修改分页条中请求地址为 url  变量输出, 并抽取一个单独的 jsp  页面

![image-20211206193858957](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206193858957.png)

#### 5、在common在创建一个名为page_nav.jsp文件

把前台的index.jsp下的分页条给放到page_nav.jsp文件当中

并把前台的index.jsp和后台的book_manager.jsp的分页条进行请求转发



### 5、首页价格搜索

![image-20211206212243850](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206212243850.png)

#### 1、在clinet的index.jsp中更改一下表单的提交地址和提交方式

![image-20211206213029043](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206213029043.png)

#### 2、在ClientBookServlet.java中创建区间分页方法

```java
protected void pageByPrice(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 获取请求的参数 pageNo 和 pageSize,和最大值，以及最小值
        int pageNo = WebUtils.parseInt(req.getParameter("pageNo"), 1);
        int pageSize = WebUtils.parseInt(req.getParameter("pageSize"), Page.PAGE_SIZE);
        int min = WebUtils.parseInt(req.getParameter("min"), 0);//默认为0，没选的话从第一开始
        int max = WebUtils.parseInt(req.getParameter("max"), Integer.MAX_VALUE);//默认为最大值，即最大书的数量（包含数据库图书的最大价格即可）

        //2 调用BookService.page(pageNo，pageSize)：Page对象
        Page<Book> page = bookService.pageByPrice(pageNo,pageSize,min,max);
        
        page.setUrl("client/bookServlet?action=pageByPrice");
        //3 保存Page对象到Request域中
        req.setAttribute("page",page);
        //4 请求转发到pages/manager/book_manager.jsp页面
        req.getRequestDispatcher("/pages/client/index.jsp").forward(req,resp);
    }

}
```

#### 3、在BookService中创建pageByPrice接口

```java
Page<Book> pageByPrice(int pageNo, int pageSize, int min, int max);
```

#### 4、在BookServiecImpl中实现接口的方法

```java
Override
    public Page<Book> pageByPrice(int pageNo, int pageSize, int min, int max) {
        Page<Book> page = new Page<Book>();

        // 设置每页显示的数量
        page.setPageSize(pageSize);
        // 求总记录数
        Integer pageTotalCount = bookDao.queryForPageTotalCountByPrice(min,max);
        // 设置总记录数
        page.setPageTotalCount(pageTotalCount);
        // 求总页码
        Integer pageTotal = pageTotalCount / pageSize;
        if (pageTotalCount % pageSize > 0) {
            pageTotal+=1;
        }
        // 设置总页码
        page.setPageTotal(pageTotal);

        // 设置当前页码
        page.setPageNo(pageNo);

        // 求当前页数据的开始索引
        int begin = (page.getPageNo() - 1) * pageSize;
        // 求当前页数据
        List<Book> items = bookDao.queryForPageItemsByPrice(begin,pageSize,min,max);
        // 设置当前页数据
        page.setItems(items);

        return page;
    }
```

#### 5、在BookDao创建Service的对应的接口

> 对应的接口为：queryForPageTotalCountByPrice按照区间的价格查找总数
>
> queryForPageItemsByPrice按照区间的价格查找当前页数据

```java
Integer queryForPageTotalCountByPrice(int min, int max);

    List<Book> queryForPageItemsByPrice(int begin, int pageSize, int min, int max);
```

#### 6、在BookDaoImpl中实现这两个方法

> 主要是能更数据库交互，做查询

```java
@Override
    public Integer queryForPageTotalCountByPrice(int min, int max) {
        String sql = "select count(*) from t_book where price between ? and ?";
        Number count = (Number) queryForSingleValue(sql,min,max);
        return count.intValue();
    }

    @Override
    public List<Book> queryForPageItemsByPrice(int begin, int pageSize, int min, int max) {
        String sql = "select `id`,`name`,`author`,`price`,`sales`,`stock`,`img_path` imgPath " +
                "from t_book where price between ? and ? order by price limit ?,?";
        return queryForList(Book.class,sql,min,max,begin,pageSize);
    }
```

#### 7、在BookDaoTest中对这两个方法进行测试

```java
 @Test
    public void queryForPageTotalCountByPrice() {
        System.out.println( bookDao.queryForPageTotalCountByPrice(10, 50) );
    }

    @Test
    public void queryForPageItems() {
        for (Book book : bookDao.queryForPageItems(8, Page.PAGE_SIZE)) {
            System.out.println(book);
        }
    }
    @Test
    public void queryForPageItemsByPrice() {
        for (Book book : bookDao.queryForPageItemsByPrice(0, Page.PAGE_SIZE,10,50)) {
            System.out.println(book);
        }
    }
```

#### 8、在主页面上输入价格后，让输入的数字回显，不至于消失

> 在client下的index.jsp把价格区间的表单用上的vlaue修改成动态的就可以了

![image-20211206215842690](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211206215842690.png)

#### 9、在进行page方法时，url地址要带上价格区间

> 如果不带有价格区间的话，那么点击其他标签机会还是按照非价格区间的方式进行跳转

```java

//将ClientBookServlet.java中的page.setUrl("client/bookServlet?action=pageByPrice");，替换为以下的即可
 StringBuilder sb = new StringBuilder("client/bookServlet?action=pageByPrice");
        // 如果有最小价格的参数,将最小价格追加到分页条的地址参数中
        if (req.getParameter("min") != null) {
            sb.append("&min=").append(req.getParameter("min"));
        }
        // 如果有最大价格的参数,将最大价格追加到分页条的地址参数中
        if (req.getParameter("max") != null) {
            sb.append("&max=").append(req.getParameter("max"));
        }
        page.setUrl(sb.toString());


//通过字符缓冲的方式进行追加
```



## 6、第六阶段

### 1、登路-显示用户名

在UserServlet 程序中保存用户登录的信息

![image-20211207175105123](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207175105123.png)

修改 login_succuess_menu.jsp

![image-20211207175145892](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207175145892.png)

修改首页的index.jsp页面的菜单

![image-20211207175333284](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207175333284.png)

### 2、等出–注销用户

```markdown
# 注销的方法
	1、销毁 Session 中用户登录的信息（或者销毁 Session）
	2、重定向到首页（或登录页面）。
```

在UserServlet程序中添加logout方法

```java
protected void logout(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1、销毁Session中用户登录的信息（或者销毁Session）
        req.getSession().invalidate();
        //2、重定向到首页（或登录页面）。
        resp.sendRedirect(req.getContextPath());
    }
```

修改关于在【销毁】的菜单地址

```markdown
<a href="userServlet?action=logout">注销</a>
```

### 3、表单重复提交–验证码

```markdown
表单重复提交有三种常见的情况：
	一：提交完表单。服务器使用请求转来进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。造成表单重复提交问题。
	解决方法：使用重定向来进行跳转

	二：用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败，就会着急，然后多点了几次提交操作，也会造成表单重复提交。

	三：用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复提交。
```

![image-20211207201357235](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207201357235.png)

### 4、把验证码放到书城项目注册当中使用

#### 1、导包

导入谷歌验证码的 jar 包 kaptcha-2.3.2.jar

#### 2、在.xml中配置用于生成验证码的Servlet

在 web.xml 中去配置用于生成验证码的 Servlet 程序(不用写相关的Servlet代码，架包里就提供了)

```xml

	<servlet>
		<servlet-name>KaptchaServlet</servlet-name>
		<servlet-class>com.google.code.kaptcha.servlet.KaptchaServlet</servlet-class>
	</servlet>
	
	<servlet-mapping>
		<servlet-name>KaptchaServlet</servlet-name>
		<url-pattern>/kaptcha.jpg</url-pattern>
	</servlet-mapping>
```

#### 3、在注册界面去更改验证码的来源地址

```jsp
<label>验证码：</label>
							<input class="itxt" type="text" style="width: 90px;" name="code" id="code"/>
							<img alt="" src="kaptcha.jpg" style="float: right; margin-right: 40px; width: 120px;height: 42px;">
```

#### 4、在服务器获取谷歌生成的验证码和客户端发送过来的验证码比较使用。

```java
protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 从谷歌生成验证码的架包的常量KAPTCHA_SESSION_KEY中获取验证码放到Session中，并从中取出验证码
        String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY);
        // 删除 Session中的验证码
        req.getSession().removeAttribute(KAPTCHA_SESSION_KEY);

        String username = req.getParameter("username");//  1、获取请求的参数
        String password = req.getParameter("password");
        String email = req.getParameter("email");
        String code = req.getParameter("code");

        //把请求的参数通过WebUtils工具注入javaBean中
        User user = WebUtils.copyParamToBean(req.getParameterMap(),new User());//这样的话，以后的上面的请求参数操作就可以省略
        Map<String,String[]> paramterMap = req.getParameterMap();
        for(Map.Entry<String,String[]> entry:paramterMap.entrySet()){
            System.out.println(entry.getKey()+"=" + Arrays.asList(entry.getValue()));
        }
        if (token!=null&&token.equalsIgnoreCase(code)) {//2、检查 验证码是否更自动生成的匹配并且存在
            //        3、检查 用户名是否可用
            if (userService.existsUsername(username)) {
                System.out.println("用户名[" + username + "]已存在!");
                // 把回显信息，保存到Request域中
                req.setAttribute("msg", "用户名已存在！！");
                req.setAttribute("username", username);
                req.setAttribute("email", email);
                //        跳回注册页面，不可用
                req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
            } else {
                //      可用
                req.getSession().setAttribute("user",user);//放到session域当中
                //                调用Sservice保存到数据库
                userService.registerUser(new User(null, username, password, email));
                //        跳到注册成功页面 regist_success.html
                req.getRequestDispatcher("/pages/user/regist_success.jsp").forward(req, resp);
            }
        } else {
            //把回显信息，保存到Request域中
            req.setAttribute("msg", "验证码错误！！");
            req.setAttribute("username", username);
            req.setAttribute("email", email);

            System.out.println("验证码[" + code + "]错误");
            req.getRequestDispatcher("/pages/user/regist.jsp").forward(req, resp);
        }
    }

    //doPost()方法不用写了，因为它继承了BaseServlet

}
```



#### 5、刷新验证码

> 为了达到看不清验证码，点击一下它就达到刷新效果，这样做：—> 给验证码绑定上单击事件，用特定的方法去刷新验证码

给form表单的验证码弄一个id标签选择器

```
id="code_img"
```



```java
// 给验证码的图片，绑定单击事件
$("#code_img").click(function () {
	// 在事件响应的 function 函数中有一个 this 对象。这个 this 对象，是当前正在响应事件的 dom 对象
	// src 属性表示验证码 img 标签的 图片路径。它可读，可写
	// alert(this.src);
	this.src = "${basePath}kaptcha.jpg?d=" + new Date();
});
```

> 解释为什么要在验证码路径后加？d=new date();

![image-20211207213116366](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207213116366.png)

因为浏览器上有缓存，我们只需要将在后面加一个随机参数，让保存在缓存区的链接，再次点击是找不到原先匹配的，从而能达到再次刷新，而不是点击一次就不能点击了。



### 5、购物车

> 把购物信息保存到Session域当中

#### 1、购物车模块分析

![image-20211207215927615](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211207215927615.png)

#### 2、购物车的两大模型

创建购物车商品项的javaBean

购物车对象

```java
package com.atguigu.pojo;

import java.math.BigDecimal;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * 购物车对象
 */
public class Cart {
//    private Integer totalCount;
//    private BigDecimal totalPrice;

    /**
     * key是商品编号，
     * value，是商品信息
     */
    private Map<Integer,CartItem> items = new LinkedHashMap<Integer,CartItem>();

    /**
     * 添加商品项
     *
     * @param cartItem
     */
    public void addItem(CartItem cartItem) {
        // 先查看购物车中是否已经添加过此商品，如果已添加，则数量累加，总金额更新，如果没有添加过，直接放到集合中即可
        CartItem item = items.get(cartItem.getId());

        if (item == null) {
            // 之前没添加过此商品
            items.put(cartItem.getId(), cartItem);
        } else {
            // 已经 添加过的情况
            item.setCount( item.getCount() + 1 ); // 数量 累加
            item.setTotalPrice( item.getPrice().multiply(new BigDecimal( item.getCount() )) ); // 更新总金额
        }

    }

    /**
     * 删除商品项
     */
    public void deleteItem(Integer id) {
        items.remove(id);
    }


    /**
     * 清空购物车
     */
    public void clear() {
        items.clear();
    }

    /**
     * 修改商品数量
     */
    public void updateCount(Integer id,Integer count) {
        // 先查看购物车中是否有此商品。如果有，修改商品数量，更新总金额
        CartItem cartItem = items.get(id);
        if (cartItem != null) {
            cartItem.setCount(count);// 修改商品数量
            cartItem.setTotalPrice( cartItem.getPrice().multiply(new BigDecimal( cartItem.getCount() )) ); // 更新总金额
        }
    }


    public Integer getTotalCount() {
        Integer totalCount = 0;

        for (Map.Entry<Integer,CartItem>entry : items.entrySet()) {
            totalCount += entry.getValue().getCount();
        }

        return totalCount;
    }


    public BigDecimal getTotalPrice() {
        BigDecimal totalPrice = new BigDecimal(0);

        for (Map.Entry<Integer,CartItem>entry : items.entrySet()) {
            totalPrice = totalPrice.add(entry.getValue().getTotalPrice());
        }

        return totalPrice;
    }


    public Map<Integer, CartItem> getItems() {
        return items;
    }

    public void setItems(Map<Integer, CartItem> items) {
        this.items = items;
    }

    @Override
    public String toString() {
        return "Cart{" +
                "totalCount=" + getTotalCount() +
                ", totalPrice=" + getTotalPrice() +
                ", items=" + items +
                '}';
    }
}

```



购物车商品项的javaBean

```java
package com.atguigu.pojo;

import java.math.BigDecimal;

/**
 * 购物车的商品项
 */
public class CartItem {
    private Integer id;
    private String name;
    private Integer count;
    private BigDecimal price;
    private BigDecimal totalPrice;

    public CartItem() {
    }

    public CartItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.price = price;
        this.totalPrice = totalPrice;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getCount() {
        return count;
    }

    public void setCount(Integer count) {
        this.count = count;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }

    @Override
    public String toString() {
        return "CartItem{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", count=" + count +
                ", price=" + price +
                ", totalPrice=" + totalPrice +
                '}';
    }
}

```

对购物车商品项进行测试

```java
package com.atguigu.test;

import com.atguigu.pojo.Cart;
import com.atguigu.pojo.CartItem;
import org.junit.Test;

import java.math.BigDecimal;

import static org.junit.Assert.*;

public class CartTest {

    @Test
    public void addItem() {
        Cart cart = new Cart();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(2, "数据结构与算法", 1, new BigDecimal(100),new BigDecimal(100)));

        System.out.println(cart);

    }

    @Test
    public void deleteItem() {

        Cart cart = new Cart();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(2, "数据结构与算法", 1, new BigDecimal(100),new BigDecimal(100)));

        cart.deleteItem(1);

        System.out.println(cart);

    }

    @Test
    public void clear() {
        Cart cart = new Cart();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(2, "数据结构与算法", 1, new BigDecimal(100),new BigDecimal(100)));

        cart.deleteItem(1);

        cart.clear();

        System.out.println(cart);
    }

    @Test
    public void updateCount() {

        Cart cart = new Cart();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(2, "数据结构与算法", 1, new BigDecimal(100),new BigDecimal(100)));

        cart.deleteItem(1);

        cart.clear();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));

        cart.updateCount(1, 10);


        System.out.println(cart);

    }
}
```

#### 3、加入购物车的功能的实现

CartServlet程序中的代码

```java
public class CartServlet extends BaseServlet {

    private BookService bookService = new BookServiceImpl();
    /**
     * 加入购物车
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void addItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取请求的参数 商品编号
        int id = WebUtils.parseInt(req.getParameter("id"), 0);
        // 调用bookService.queryBookById(id):Book得到图书的信息(从数据库中找)
        Book book = bookService.queryBookById(id);
        // 把图书信息，转换成为CartItem商品项
        CartItem cartItem = new CartItem(book.getId(),book.getName(),1,book.getPrice(),book.getPrice());
        // 调用Cart.addItem(CartItem);添加商品项
        Cart cart = (Cart) req.getSession().getAttribute("cart");
        if (cart == null) {
            cart = new Cart();
            req.getSession().setAttribute("cart",cart);
        }
        cart.addItem(cartItem);

        System.out.println(cart);
        System.out.println("请求头Referer的值：" + req.getHeader("Referer"));
        // 最后一个添加的商品名称
        req.getSession().setAttribute("lastName", cartItem.getName());

        // 重定向回原来商品所在的地址页面，这样点解加入购物车后，不至于跳回最初始的界面
        resp.sendRedirect(req.getHeader("Referer"));
    }
}

```

index.jsp的js代码

![image-20211208113926397](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208113926397.png)

给加入购物车绑定单击事件

```jsp
<Script type="text/javascript">
    $(function () {
        // 给加入购物车按钮绑定单击事件
        $("button.addToCart").click(function () {
            /**
            * 在事件响应的 function 函数 中，有一个 this 对象，这个 this 对象，是当前正在响应事件的 dom 对象,即当前标签
            * @type {jQuery}
            */
            var bookId = $(this).attr("bookId");//获取标签的id,也就是页面的第几个
            //通过location.href发生跳转给servlet
            location.href = "http://localhost:8080/book/cartServlet?action=addItem&id=" + bookId;
        });
    });
</Script>
```

配置xml

![image-20211208114447933](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208114447933.png)

> 图解说明   如何跳回添加商品的页面

![image-20211208114534385](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208114534385.png)

#### 4、购物车展示

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>购物车</title>
	<%@ include file="/pages/common/head.jsp"%>
</head>
<body>
	
	<div id="header">
			<img class="logo_img" alt="" src="static/img/logo.gif" >
			<span class="wel_word">购物车</span>
			<%@ include file="/pages/common/login_success_menu.jsp"%>
	</div>
	
	<div id="main">

		<table>
			<tr>
				<td>商品名称</td>
				<td>数量</td>
				<td>单价</td>
				<td>金额</td>
				<td>操作</td>
			</tr>
			<c:if test="${empty sessionScope.cart.items}">
				<%-- 如果购物车空的情况 --%>
				<tr> <%--跨5行输出--%>
					<td colspan="5"><a href="index.jsp">亲，当前购物车为空！快跟小伙伴们去浏览商品吧！！！</a>
					</td>
				</tr>
			</c:if>
			<c:if test="${not empty sessionScope.cart.items}">
				<%-- 如果购物车非空的情况 --%>
				<c:forEach items="${sessionScope.cart.items}" var="entry">
					<tr>
						<td>${entry.value.name}</td>
						<td>${entry.value.count}</td>
						<td>${entry.value.price}</td>
						<td>${entry.value.totalPrice}</td>
						<td><a href="#">删除</a></td>
					</tr>
				</c:forEach>
			</c:if>
		</table>
		<%-- 如果购物车非空才输出页面的内容 --%>
		<c:if test="${not empty sessionScope.cart.items}">
			<div class="cart_info">
				<span class="cart_span">购物车中共有<span class="b_count">${sessionScope.cart.totalCount}</span>件商品</span>
				<span class="cart_span">总金额<span class="b_price">${sessionScope.cart.totalPrice}</span>元</span>
				<span class="cart_span"><a href="#">清空购物车</a></span>
				<span class="cart_span"><a href="pages/cart/checkout.jsp">去结账</a></span>
			</div>
		</c:if>
	</div>
	
	</div>

	<%@ include file="/pages/common/footer.jsp"%>
</body>
</html>
```

#### 5、删除购物车的商品想

CartServlet程序添加删除商品项方法

```java
/**
     * 删除商品项
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void deleteItem(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{
        // 获取商品编号
        int id = WebUtils.parseInt(req.getParameter("id"), 0);
        // 获取购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");

        if (cart != null) {
            // 删除 了购物车商品项
            cart.deleteItem(id);
            // 重定向回原来购物车展示页面
            resp.sendRedirect(req.getHeader("Referer"));
        }

    }
```

购物车/pages/cart/cart.jsp 页面的代码：

给删除标签的请求地址发给CartServlet并且绑定单击事件

![image-20211208150251958](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208150251958.png)

删除确认提示操作

```javascript
	$(function () {
				// 给 【删除】绑定单击事件
				$("a.deleteItem").click(function () {
					return confirm("你确定要删除【" + $(this).parent().parent().find("td:first").text() +"】吗?")
				});

			});
```

#### 6、清空购物车

CartServlet程序中清空购物车的方法

```java
/**
     * 清空购物车
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void clear(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{
        // 1 获取购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");
        if (cart != null) {
            // 清空购物车
            cart.clear();
            // 重定向回原来购物车展示页面
            resp.sendRedirect(req.getHeader("Referer"));
        }
    }
```



cart.jsp页面的内容

给清空购物车添加请求地址，和添加 id 属性（用于绑定事件）：

![image-20211208151352040](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208151352040.png)

清空的确认提示操作

```javascript
				// 给清空购物车绑定单击事件
				$("#clearCart").click(function () {
					return confirm("你确定要清空购物车吗?");
				});
```

#### 7、修改商品数量

在CartServlet程序中增加修改商品数量方法

```java
/**
     * 修改商品数量
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void updateCount(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{
        // 获取请求的参数 商品编号 、商品数量
        int id = WebUtils.parseInt(req.getParameter("id"),0);
        int count = WebUtils.parseInt(req.getParameter("count"), 1);
        // 获取Cart购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");

        if (cart != null) {
            // 修改商品数量
            cart.updateCount(id,count);
            // 重定向回原来购物车展示页面
            resp.sendRedirect(req.getHeader("Referer"));
        }
```

修改pages/cart/cart.jsp购物车页面

![image-20211208153253281](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208153253281.png)

修改商品数量的js代码

```javascript
// 给输入框绑定 onchange内容发生改变事件(即，输入框发生改动，离开输入框就会发生提示)
				$(".updateCount").change(function () {
					// 获取商品名称
					var name = $(this).parent().parent().find("td:first").text();
					var id = $(this).attr('bookId');
					// 获取商品数量
					var count = this.value;
					if ( confirm("你确定要将【" + name + "】商品修改数量为：" + count + " 吗?") ) {
						//发起请求。给服务器保存修改
						location.href = "http://localhost:6211/Book_Web/cartServlet?action=updateCount&count="+count+"&id="+id;
					} else {
						// defaultValue属性是表单项Dom对象的属性。它表示默认的value修改之前的属性值。
						this.value = this.defaultValue;
					}
				});
```

#### 8、首页购物车数据回显

> 在添加商品到购物车的时候，保存最后一个添加的商品名称：

在CartServlet的addItem增加添加最后一个商品名称的语句

```java
req.getSession().setAttribute("lastName", cartItem.getName());
```

> 在pages/client/index.jsp 页面中输出购物车信息：

```jsp
<div style="text-align: center">
				<c:if test="${empty sessionScope.cart.items}">
					<%--购物车为空的话--%>
					<span></span>
					<div>
						<span style="color: red">当前购物车为空</span>
					</div>
				</c:if>
				<c:if test="${not empty sessionScope.cart.items}">
					<%--购物车非空输出--%>
					<span>您的购物车中有${sessionScope.cart.totalCount}件商品</span>
					<div>
						您刚刚将<span style="color: red">${sessionScope.lastName}</span>加入到了购物车中
					</div>
				</c:if>
			</div>
```

## 第七阶段：订单

### 1、订单模块的分析

![image-20211208162649752](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208162649752.png)

### 2、订单模块的实现

#### 1、创建订单模块的数据库表

```markdown
## 订单表
create table t_order(
	`order_id` varchar(50) primary key,  	##订单号
	`create_time` datetime not null,	##订单时间
	`total_money` decimal(11,2) not null,	##总金额 
	`status` int not null default 0, 	##物流状态：0-未发货、1-等待用户签收、2-用户已签收
	`user_id` int not null,			##用户编号
	foreign key (`user_id`) references t_user(`id`)
);


## 订单项
create table t_order_item(
	`id` int primary key auto_increment, 
	`name` varchar(30) not null,		##商品名
	`price` decimal(11,2),			##商品单价
	`total_money` decimal(11,2),		##商品总金额
	`count` int not null,			##商品数量
	`order_id` varchar(50) not null,	##订单号
	foreign key (`order_id`) references t_order(`order_id`)
);
```

#### 2、创建订单模块的数据模型

订单order的javaBean

```java
package com.atguigu.pojo;

import java.math.BigDecimal;
import java.util.Date;

/**
 * 订单
 */
public class Order {
    private String orderId;
    private Date createTime;
    private BigDecimal price;
    // 0未发货，1已发货，2表示已签收
    private Integer status = 0;
    private Integer userId;

    public Order(String orderId, Date createTime, BigDecimal price, Integer status, Integer userId) {
        this.orderId = orderId;
        this.createTime = createTime;
        this.price = price;
        this.status = status;
        this.userId = userId;
    }

    public Order() {
    }

    public String getOrderId() {
        return orderId;
    }

    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId='" + orderId + '\'' +
                ", createTime=" + createTime +
                ", price=" + price +
                ", status=" + status +
                ", userId=" + userId +
                '}';
    }
}

```

订单项orderItem的javaBean

```java
package com.atguigu.pojo;

import java.math.BigDecimal;

/**
 * 订单项
 */
public class OrderItem {
    private Integer id;
    private String name;
    private Integer count;
    private BigDecimal price;
    private BigDecimal totalPrice;
    private String orderId;



    public OrderItem() {
    }

    public OrderItem(Integer id, String name, Integer count, BigDecimal price, BigDecimal totalPrice, String orderId) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.price = price;
        this.totalPrice = totalPrice;
        this.orderId = orderId;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getCount() {
        return count;
    }

    public void setCount(Integer count) {
        this.count = count;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }

    public String getOrderId() {
        return orderId;
    }

    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }

    @Override
    public String toString() {
        return "OrderItem{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", count=" + count +
                ", price=" + price +
                ", totalPrice=" + totalPrice +
                ", orderId='" + orderId + '\'' +
                '}';
    }
}

```

#### 3、编写订单模块的Dao程序和测试

OrderDao接口

```java
public interface OrderDao {

    public int saveOrder(Order order);//保存订单
    
}
```

OrderDao实现

```java
public class OrderDaoImpl extends BaseDao implements OrderDao {
    @Override
    public int saveOrder(Order order) {
        String sql = "insert into t_order(`order_id`,`create_time`,`price`,`status`,`user_id`) values(?,?,?,?,?)";

        return update(sql,order.getOrderId(),order.getCreateTime(),order.getPrice(),order.getStatus(),order.getUserId());
    }
}
```

OrderItemDao接口

```java
public interface OrderItemDao {
    public int saveOrderItem(OrderItem orderItem);
}
```

OrderItemDao实现

```java
public class OrderItemDaoImpl extends BaseDao implements OrderItemDao {
    @Override
    public int saveOrderItem(OrderItem orderItem) {
        String sql = "insert into t_order_item(`name`,`count`,`price`,`total_price`,`order_id`) values(?,?,?,?,?)";
        return update(sql,orderItem.getName(),orderItem.getCount(),orderItem.getPrice(),orderItem.getTotalPrice(),orderItem.getOrderId());
    }
}
```

OrderDaoTest

```java
public class OrderDaoTest {

    @Test
    public void saveOrder() {

        OrderDao orderDao = new OrderDaoImpl();

        orderDao.saveOrder(new Order("1234567891",new Date(),new BigDecimal(100),0, 1));

    }
}
```

OrderDaoImplTest

```java
public class OrderItemDaoTest {

    @Test
    public void saveOrderItem() {
        OrderItemDao orderItemDao = new OrderItemDaoImpl();

        orderItemDao.saveOrderItem(new OrderItem(null,"java从入门到精通", 1,new BigDecimal(100),new BigDecimal(100),"1234567891"));
        orderItemDao.saveOrderItem(new OrderItem(null,"javaScript从入门到精通", 2,new BigDecimal(100),new BigDecimal(200),"1234567891"));
        orderItemDao.saveOrderItem(new OrderItem(null,"Netty入门", 1,new BigDecimal(100),new BigDecimal(100),"1234567891"));

    }
}
```

#### 4、编写订单模块的Service和测试

OrderService接口

```java
public interface OrderService {
    public String createOrder(Cart cart,Integer userId);
}

```

OrderService实现类

```java
public class OrderServiceImpl implements OrderService {

    private OrderDao orderDao = new OrderDaoImpl();
    private OrderItemDao orderItemDao = new OrderItemDaoImpl();
    private BookDao bookDao = new BookDaoImpl();

    @Override
    public String createOrder(Cart cart, Integer userId) {
        // 订单号===唯一性
        String orderId = System.currentTimeMillis()+""+userId;
        // 创建一个订单对象
        Order order = new Order(orderId,new Date(),cart.getTotalPrice(), 0,userId);
        // 保存订单
        orderDao.saveOrder(order);

        // 遍历购物车中每一个商品项转换成为订单项保存到数据库
        for (Map.Entry<Integer, CartItem>entry : cart.getItems().entrySet()){
            // 获取每一个购物车中的商品项
            CartItem cartItem = entry.getValue();
            // 转换为每一个订单项
            OrderItem orderItem = new OrderItem(null,cartItem.getName(),cartItem.getCount(),cartItem.getPrice(),cartItem.getTotalPrice(), orderId);
            // 保存订单项到数据库
            orderItemDao.saveOrderItem(orderItem);

            // 更新库存和销量
            Book book = bookDao.queryBookById(cartItem.getId());
            book.setSales( book.getSales() + cartItem.getCount() );
            book.setStock( book.getStock() - cartItem.getCount() );
            bookDao.updateBook(book);

        }
        // 清空购物车
        cart.clear();

        return orderId;
    }
}
```

OrderServiceTest

```java
import java.math.BigDecimal;

public class OrderServiceTest {

    @Test
    public void createOrder() {

        Cart cart = new Cart();

        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(1, "java从入门到精通", 1, new BigDecimal(1000),new BigDecimal(1000)));
        cart.addItem(new CartItem(2, "数据结构与算法", 1, new BigDecimal(100),new BigDecimal(100)));

        OrderService orderService = new OrderServiceImpl();

        System.out.println( "订单号是：" + orderService.createOrder(cart, 1) );

    }
}
```

#### 5、编写订单模块的web层和页面联调

OrderServlet程序

```java
package com.atguigu.web;

import com.atguigu.pojo.Cart;
import com.atguigu.pojo.User;
import com.atguigu.service.OrderService;
import com.atguigu.service.impl.OrderServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class OrderServlet extends BaseServlet {

    private OrderService orderService = new OrderServiceImpl();

    /**
     * 生成订单
     *
     * @param req
     * @param resp
     * @throws ServletException
     * @throws IOException
     */
    protected void createOrder(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 先获取Cart购物车对象
        Cart cart = (Cart) req.getSession().getAttribute("cart");
        // 获取Userid
        User loginUser = (User) req.getSession().getAttribute("user");

        if (loginUser == null) {
            req.getRequestDispatcher("/pages/user/login.jsp").forward(req,resp);
            return;
        }

        Integer userId = loginUser.getId();
//        调用orderService.createOrder(Cart,Userid);生成订单
        String orderId = orderService.createOrder(cart, userId);

//        req.setAttribute("orderId", orderId);
        // 请求转发到/pages/cart/checkout.jsp
//        req.getRequestDispatcher("/pages/cart/checkout.jsp").forward(req, resp);

        req.getSession().setAttribute("orderId",orderId);

        resp.sendRedirect(req.getContextPath()+"/pages/cart/checkout.jsp");
    }

}

```

配置xml地址

![image-20211208175705313](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208175705313.png)

修改 pages/cart/cart.jsp 页面，结账的请求地址：

![image-20211208175722877](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208175722877.png)

修改 pages/cart/checkout.jsp 页面，输出订单号

![image-20211208175738920](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211208175738920.png)

## 第八阶段



### 1、使用Filter 过滤器拦截/pages/manager/所有内容，实 所有内容，实现权限检查

> 需求：没有登路并且登陆上不是后台人员不让进

Filter代码

```java
public class ManagerFilter implements Filter{
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;

        Object user = httpServletRequest.getSession().getAttribute("user");
        if (user == null ) {
            httpServletRequest.getRequestDispatcher("/pages/user/login.jsp").forward(servletRequest,servletResponse);
        } else {
            User manager = (User)user;
            if(manager.getUsername() != "admin"){//不是管理员不让看
                httpServletRequest.getRequestDispatcher("/pages/user/login.jsp").forward(servletRequest,servletResponse);
            }else{
                filterChain.doFilter(servletRequest,servletResponse);
            }

        }
    }

    @Override
    public void destroy() {

    }
}

```

web.xml中的配置

![image-20211209084744249](%E4%B9%A6%E5%9F%8E%E9%A1%B9%E7%9B%AE.assets/image-20211209084744249.png)



### 2、ThreadLocal的使用

```markdown
	1、ThreadLocal 的作用，它可以解决多线程的数据安全问题。ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合）

ThreadLocal 的特点：
	1、ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程）
	2、每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal 对象实例。
	
	3、每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型
4、ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放。
```

测试类

```java
public class OrderService {
    public void createOrder(){
        String name = Thread.currentThread().getName();
        System.out.println("OrderService  当前线程[" + name + "] 中保存的数据是：" +
                ThreadLocalTest.threadLocal.get());
        new OrderDao().saveOrder();
    }
}
public class OrderDao {
    public void saveOrder(){
        String name = Thread.currentThread().getName();
        System.out.println("OrderDao  当前线程[" + name + "] 中保存的数据是：" +
                ThreadLocalTest.threadLocal.get());
    }
}
public class ThreadLocalTest {
    // public static Map<String,Object> data = new Hashtable<String,Object>();
    public static ThreadLocal<Object> threadLocal = new ThreadLocal<Object>();
    private static Random random = new Random();
    public static class Task implements Runnable {
        @Override
        public void run() {
            // 在 Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为 key 保存到 map 中
            Integer i = random.nextInt(1000);
            // 获取当前线程名
            String name = Thread.currentThread().getName();
            System.out.println(" 线程["+name+"] 生成的随机数是：" + i);
            // data.put(name,i);
            threadLocal.set(i);
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            new OrderService().createOrder();
            // 在 Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作
            // Object o = data.get(name);
            Object o = threadLocal.get();
            System.out.println(" 在线程["+name+"] 快结束时取出关联的数据是：" + o);
        }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 3; i++){
            new Thread(new Task()).start();
        }
    }
}

```

